IF OBJECT_ID('DBO.REP_SLICHIT_STATEMENT_EX') IS NULL EXEC('CREATE PROCEDURE DBO.REP_SLICHIT_STATEMENT_EX AS RETURN')
GO
ALTER PROCEDURE REP_SLICHIT_STATEMENT_EX
	@XMLPARAM NTEXT
AS

DECLARE @ID_CONTRACTOR_STU VARCHAR(50)
SELECT @ID_CONTRACTOR_STU = ID_CONTRACTOR FROM CONTRACTOR WHERE [NAME] = 'СТУ'

DECLARE @FILE_DATA TABLE(
	[NAME] VARCHAR(255),
	BARCODE VARCHAR(40),
	CODE_STU VARCHAR(20),
	QUANTITY MONEY,
	PRICE_SAL MONEY,
	PRICE_SUP MONEY,
	INV_INDEX BIGINT
)

DECLARE @INVENTORY_DATA TABLE(
	[INDEX] BIGINT IDENTITY(1, 1),
	ID_GOODS BIGINT,
	BARCODE VARCHAR(40),
	CODE_STU VARCHAR(20),
	QUANTITY MONEY,
	PRICE_SAL MONEY,
	PRICE_SUP MONEY)

DECLARE @RESULT TABLE(
	COUNTER INT,
	GOODS_NAME VARCHAR(255),
	CODE VARCHAR(16),
	Q_ADD MONEY,
	SUM_ADD MONEY,
	Q_SUB MONEY,
	SUM_SUB MONEY,
	CODE_STU VARCHAR(50),
	BARCODE VARCHAR(50),
	Q_FILE MONEY,
	Q_DOCUMENT MONEY
)

DECLARE @HDOC INT, @ERROR INT

EXEC SP_XML_PREPAREDOCUMENT @HDOC OUTPUT, @XMLPARAM OUTPUT
	SELECT * INTO #TAB FROM OPENXML(@HDOC, '//XML') WITH(
		ID_INVENTORY_GLOBAL UNIQUEIDENTIFIER 'ID_INVENTORY_GLOBAL')
EXEC SP_XML_REMOVEDOCUMENT @HDOC

-- Выбираем из файла данные с заполненым штрих-кодом и группируем по штрихкоду, для подсчета общего количества товара
INSERT INTO @FILE_DATA 	([NAME], BARCODE, QUANTITY, PRICE_SAL, PRICE_SUP, CODE_STU)
SELECT [NAME], 
	BARCODE,
	SUM(KOL / Q_FIRST), 
	MAX(SALE_PRICE * Q_FIRST), 
	MAX(COST_PRICE * Q_FIRST),
	MIN(CODE_STU)
FROM STU_OST_INV
WHERE LEN(BARCODE) > 0
GROUP BY 
	[NAME],
	BARCODE

-- Выбираем из файла данные без ШК, группируем по коду СТУ, цене розничной и цене производителя
INSERT INTO @FILE_DATA 	([NAME], CODE_STU, QUANTITY, PRICE_SAL, PRICE_SUP)
SELECT 
	[NAME], 
	CODE_STU, 
	SUM(KOL / Q_FIRST), 
	SALE_PRICE * Q_FIRST,
	COST_PRICE * Q_FIRST 
FROM STU_OST_INV
WHERE BARCODE IS NULL OR LEN(BARCODE) = 0
GROUP BY 
	[NAME],
	CODE_STU, 
	SALE_PRICE * Q_FIRST,
	COST_PRICE * Q_FIRST

-- Проставляем наименование товара для тех товаров у которых код СТУ соответсвует единственному товару
UPDATE @FILE_DATA SET [NAME] = T.[NAME]
FROM
(
SELECT G.[NAME], CODE_STU FROM @FILE_DATA FD
	INNER JOIN GOODS_CODE GC ON GC.CODE = FD.CODE_STU AND GC.ID_CONTRACTOR = @ID_CONTRACTOR_STU
	INNER JOIN GOODS G ON G.ID_GOODS = GC.ID_GOODS
	WHERE FD.CODE_STU IN (SELECT CODE FROM GOODS_CODE WHERE ID_CONTRACTOR = @ID_CONTRACTOR_STU GROUP BY CODE HAVING COUNT(*) = 1)
) T, @FILE_DATA FD
WHERE T.CODE_STU = FD.CODE_STU


INSERT INTO @INVENTORY_DATA (ID_GOODS, BARCODE, QUANTITY, PRICE_SAL, PRICE_SUP)
SELECT 
	IVI.ID_GOODS,
	SL.CODE,
	SUM(IVI.QUANTITY * CONVERT(MONEY, SR.NUMERATOR) / CONVERT(MONEY, SR.DENOMINATOR)),
	MAX(IVI.PRICE_SAL * CONVERT(MONEY, SR.DENOMINATOR) / CONVERT(MONEY, SR.NUMERATOR)),
	MAX(IVI.PRICE_SUP * CONVERT(MONEY, SR.DENOMINATOR) / CONVERT(MONEY, SR.NUMERATOR))
FROM #TAB T
INNER JOIN INVENTORY_VED IV ON IV.ID_INVENTORY_SVED_GLOBAL = T.ID_INVENTORY_GLOBAL
INNER JOIN INVENTORY_VED_ITEM IVI ON IVI.ID_INVENTORY_VED_GLOBAL = IV.ID_INVENTORY_VED_GLOBAL
LEFT JOIN STU_LOT SL ON SL.ID_INVENTORY_VED_ITEM_GLOBAL = IVI.ID_INVENTORY_VED_ITEM_GLOBAL
INNER JOIN SCALING_RATIO SR ON SR.ID_SCALING_RATIO = IVI.ID_SCALING_RATIO
GROUP BY
	SL.CODE,
	IVI.ID_GOODS

UPDATE @FILE_DATA SET INV_INDEX = T.[INDEX]
FROM @FILE_DATA FD, @INVENTORY_DATA T
WHERE (LEN(FD.BARCODE) > 0 AND FD.BARCODE = T.BARCODE)
OR (LEN(FD.BARCODE) = 0 AND FD.CODE_STU IN
	(SELECT CODE FROM GOODS_CODE CCC WHERE CCC.ID_CONTRACTOR = @ID_CONTRACTOR_STU AND CCC.ID_GOODS = T.ID_GOODS AND DATE_DELETED IS NULL)
	AND FD.PRICE_SAL = T.PRICE_SAL AND FD.PRICE_SUP = T.PRICE_SUP)


-- Излишки совпадающих в файле и инвенторизации товаров
INSERT INTO @RESULT (GOODS_NAME, CODE, Q_SUB, SUM_SUB, CODE_STU, BARCODE, Q_FILE, Q_DOCUMENT)
SELECT
	G.NAME,
	G.CODE,
	FD.QUANTITY - T.QUANTITY,
	FD.QUANTITY * FD.PRICE_SAL - T.QUANTITY * T.PRICE_SAL,
	FD.CODE_STU,
	FD.BARCODE,
	FD.QUANTITY,
	T.QUANTITY
FROM
	@INVENTORY_DATA T
	INNER JOIN @FILE_DATA FD ON FD.INV_INDEX = T.[INDEX]
	INNER JOIN GOODS G ON G.ID_GOODS = T.ID_GOODS
WHERE FD.QUANTITY > T.QUANTITY

-- Недостача совпадающих в файле и инвенторизации товаров
INSERT INTO @RESULT (GOODS_NAME, CODE, Q_ADD, SUM_ADD, CODE_STU, BARCODE, Q_FILE, Q_DOCUMENT)
SELECT
	G.NAME,
	G.CODE,
	T.QUANTITY - FD.QUANTITY,
	T.QUANTITY * T.PRICE_SAL - FD.QUANTITY * FD.PRICE_SAL,
	T.CODE_STU,
	T.BARCODE,
	FD.QUANTITY,
	T.QUANTITY
FROM
	@INVENTORY_DATA T
	INNER JOIN @FILE_DATA FD ON FD.INV_INDEX = T.[INDEX]
	INNER JOIN GOODS G ON G.ID_GOODS = T.ID_GOODS
WHERE FD.QUANTITY < T.QUANTITY

-- Излишки совпадающих в файле и инвенторизации товаров
-- с одинаковым кол-вом, но ценой в инвенторизации большей чем в файле
INSERT INTO @RESULT (GOODS_NAME, CODE, Q_ADD, SUM_ADD, CODE_STU, BARCODE, Q_FILE, Q_DOCUMENT)
SELECT
	G.NAME,
	G.CODE,
	NULL,
	FD.QUANTITY * FD.PRICE_SAL - T.QUANTITY * T.PRICE_SAL,
	FD.CODE_STU,
	FD.BARCODE,
	FD.QUANTITY,
	T.QUANTITY
FROM
	@INVENTORY_DATA T
	INNER JOIN @FILE_DATA FD ON FD.INV_INDEX = T.[INDEX]
	INNER JOIN GOODS G ON G.ID_GOODS = T.ID_GOODS
WHERE FD.QUANTITY = T.QUANTITY AND FD.PRICE_SAL > T.PRICE_SAL

-- Излишки совпадающих в файле и инвенторизации товаров
-- с одинаковым кол-вом, но ценой в инвенторизации меньшей чем в файле
INSERT INTO @RESULT (GOODS_NAME, CODE, Q_SUB, SUM_SUB, CODE_STU, BARCODE, Q_FILE, Q_DOCUMENT)
SELECT
	G.NAME,
	G.CODE,
	NULL,
	T.QUANTITY * T.PRICE_SAL - FD.QUANTITY * FD.PRICE_SAL,
	T.CODE_STU,
	T.BARCODE,
	FD.QUANTITY,
	T.QUANTITY
FROM
	@INVENTORY_DATA T
	INNER JOIN @FILE_DATA FD ON FD.INV_INDEX = T.[INDEX]
	INNER JOIN GOODS G ON G.ID_GOODS = T.ID_GOODS
WHERE FD.QUANTITY = T.QUANTITY AND FD.PRICE_SAL < T.PRICE_SAL

-- Товары имеющиеся в файле, но отсуствующие в инвенторизации попадают в излишки
INSERT INTO @RESULT (GOODS_NAME, CODE, Q_SUB, SUM_SUB, CODE_STU, BARCODE, Q_FILE, Q_DOCUMENT)
SELECT
	FD.NAME,
	NULL,
	FD.QUANTITY,
	FD.QUANTITY * FD.PRICE_SAL,
	FD.CODE_STU,
	FD.BARCODE,
	FD.QUANTITY,
	0
FROM @FILE_DATA FD
WHERE INV_INDEX IS NULL

-- Товары отсутсвующие в файле, но присутсвующие в инвенторизации попадают в недостачу
INSERT INTO @RESULT (GOODS_NAME, CODE, Q_ADD, SUM_ADD, CODE_STU, BARCODE, Q_FILE, Q_DOCUMENT)
SELECT
	G.NAME,
	G.CODE,
	T.QUANTITY,
	T.QUANTITY * T.PRICE_SAL,
	T.CODE_STU,
	T.BARCODE,
	0,
	T.QUANTITY
FROM @INVENTORY_DATA T
INNER JOIN GOODS G ON G.ID_GOODS = T.ID_GOODS
WHERE [INDEX] NOT IN (SELECT ISNULL(INV_INDEX, 0) FROM @FILE_DATA)

SELECT * FROM @RESULT ORDER BY GOODS_NAME

RETURN 0
GO


--REP_SLICHIT_STATEMENT_EX '<XML><ID_INVENTORY_GLOBAL>D140F844-8686-49CB-9FE9-4BDB4264AB25</ID_INVENTORY_GLOBAL></XML>'
