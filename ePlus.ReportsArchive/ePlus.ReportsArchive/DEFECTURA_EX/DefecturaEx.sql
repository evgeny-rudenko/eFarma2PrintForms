SET NOCOUNT ON
SET QUOTED_IDENTIFIER OFF
GO

IF OBJECT_ID('DBO.REP_DEFECTURA_EX') IS NULL EXEC('CREATE PROCEDURE DBO.REP_DEFECTURA_EX AS RETURN')
GO

ALTER PROCEDURE DBO.REP_DEFECTURA_EX
    @XMLPARAM NTEXT AS

DECLARE @HDOC INT
DECLARE @QTY_MIN MONEY             -- минимальное количество
DECLARE @SORT INT                  -- 0 - по товару 1 - по поставщику а затем по товару
DECLARE @DATE DATETIME             -- дата остатков
DECLARE @DATE_FROM DATETIME        -- ограничение по товарам снизу (т.е. не все товары которые попали в дефектуру, 
                                   -- а только те у которых было движение за указанный период)
DECLARE @OA_ONLY BIT               -- только товары с признаком ќј
DECLARE @IS_ES BIT                 -- сформировать по единому справочнику
DECLARE @USE_GOODS_REPORT_NAME BIT -- сворачивать то группам
DECLARE @ALL_GOODS BIT             -- все товары
DECLARE @ALL_STORE BIT             -- все склады
DECLARE @ID_USER VARCHAR(36)	   -- id пользовател€
DECLARE @ID_STORE BIGINT	   -- id склада

EXEC SP_XML_PREPAREDOCUMENT @HDOC OUT, @XMLPARAM
    SELECT TOP 1
        @QTY_MIN = QTY_MIN,
        @SORT = SORT,
        @DATE = DATE,
        @DATE_FROM = DATE_FROM,
        @OA_ONLY = OA_ONLY,
        @USE_GOODS_REPORT_NAME = USE_GOODS_REPORT_NAME,
        @IS_ES = IS_ES,
	@ID_USER = ID_USER,
	@ID_STORE = ID_STORE
    FROM OPENXML(@HDOC, '//XML', 2) WITH(
        QTY_MIN MONEY 'QTY_MIN',
        SORT BIT 'SORT',
        DATE DATETIME 'DATE',
        DATE_FROM DATETIME 'DATE_FROM',
        OA_ONLY BIT 'OA_ONLY',
        USE_GOODS_REPORT_NAME BIT 'USE_GOODS_REPORT_NAME',
        IS_ES BIT 'IS_ES',
	ID_USER VARCHAR(36) 'ID_USER',
	ID_STORE BIGINT 'ID_STORE')
    SELECT ID_GOODS INTO #GOODS FROM OPENXML(@HDOC, '//XML/ID_GOODS') WITH(ID_GOODS BIGINT '.')
    IF @@ROWCOUNT = 0 SET @ALL_GOODS = 1 ELSE SET @ALL_GOODS = 0

DECLARE @ID_DEFECTURA_GLOBAL UNIQUEIDENTIFIER

EXEC SP_XML_REMOVEDOCUMENT @HDOC
--EXEC USP_RANGE_DAYS @DATE_FROM OUT, @DATE OUT
--EXEC USP_RANGE_NORM @DATE_FROM OUT, @DATE OUT

--  DELETE DEFECTURA_ITEM
--  DELETE DEFECTURA
-- дефектура юзера
SELECT 
    @ID_DEFECTURA_GLOBAL = ID_DEFECTURA_GLOBAL
FROM DEFECTURA
WHERE ID_USER = @ID_USER

EXEC USP_DEFECTURA_REFRESH @DATE_FROM, @DATE, @QTY_MIN, @ID_STORE, @ID_USER 

SELECT 
    GOODS_NAME = G.NAME,
    D.ID_CONTRACTOR,
    CONTRACTOR_NAME = C.NAME,
    G.ID_GOODS_GLOBAL, 
    D.ID_GOODS,
    ID_GOODS_CLASSIFIER = CONVERT(UNIQUEIDENTIFIER, NULL),
    PRODUCER_NAME = P.NAME,
    D.QTY_REMAIN,
    D.QTY_MIN,
    LAST_PRICE_SAL,
    LAST_PRICE_SUP,
    LAST_SUPPLIER = SUP.NAME,
    D.DELETED,
    ID_DEFECTURA_GLOBAL,
    LAST_LOT_DATE   
INTO #DEFECTURA

FROM DEFECTURA_ITEM D
    INNER JOIN GOODS G ON G.ID_GOODS = D.ID_GOODS
    LEFT JOIN PRODUCER P ON P.ID_PRODUCER = G.ID_PRODUCER
    LEFT JOIN CONTRACTOR C ON C.ID_CONTRACTOR = D.ID_CONTRACTOR
    LEFT JOIN CONTRACTOR SUP ON SUP.ID_CONTRACTOR = D.ID_SUPPLIER_LAST
WHERE (ISNULL(D.DELETED,0) = 0)
AND (ISNULL(@OA_ONLY, 0) = 0 OR G.REQUIRIED = 1)
AND (@ALL_GOODS = 1 OR EXISTS (SELECT TOP 1 1 FROM #GOODS WHERE #GOODS.ID_GOODS = G.ID_GOODS))
AND D.ID_DEFECTURA_GLOBAL = @ID_DEFECTURA_GLOBAL

IF (@USE_GOODS_REPORT_NAME=1) BEGIN

    UPDATE #DEFECTURA SET
        GOODS_NAME = ISNULL(GC.NAME, GOODS_NAME),
        PRODUCER_NAME = CASE GC.NAME WHEN NULL THEN PRODUCER_NAME ELSE NULL END,
        ID_GOODS = CASE GC.ID_GOODS_CLASSIFIER WHEN NULL THEN #DEFECTURA.ID_GOODS ELSE NULL END,
        ID_GOODS_CLASSIFIER = GC.ID_GOODS_CLASSIFIER
    FROM GOODS_CLASSIFIER_2_GOODS GC2G
    INNER JOIN GOODS_CLASSIFIER GC ON GC.ID_GOODS_CLASSIFIER = GC2G.ID_GOODS_CLASSIFIER
    WHERE GC2G.ID_GOODS = #DEFECTURA.ID_GOODS_GLOBAL
    
    SELECT    
        DI.CONTRACTOR_NAME,
        DI.ID_GOODS,
        ID_GOODS_GLOBAL = NULL,
        DI.ID_GOODS_CLASSIFIER,
        DI.GOODS_NAME,
        DI.PRODUCER_NAME,
        QTY_REMAIN = SUM(DI.QTY_REMAIN),
        QTY_MIN = MAX(DI.QTY_MIN),
        LAST_PRICE_SAL = MAX(DI.LAST_PRICE_SAL),
        LAST_PRICE_SUP = MAX(DI.LAST_PRICE_SUP),
        LAST_SUPPLIER = MAX(DI.LAST_SUPPLIER),
        LAST_LOT_DATE = MAX(DI.LAST_LOT_DATE),
        DELETED = MAX(CONVERT(INT, DI.DELETED))
    FROM #DEFECTURA DI
    INNER JOIN DEFECTURA D ON D.ID_DEFECTURA_GLOBAL = DI.ID_DEFECTURA_GLOBAL
    WHERE NOT EXISTS (SELECT NULL 
                      FROM LOT_PERIOD_REM LPR 
                      INNER JOIN LOT L ON L.ID_LOT_GLOBAL = LPR.ID_LOT_GLOBAL
                      INNER JOIN GOODS G ON G.ID_GOODS = L.ID_GOODS
                      LEFT JOIN GOODS_CLASSIFIER_2_GOODS GC2G ON GC2G.ID_GOODS = G.ID_GOODS_GLOBAL
                      WHERE LPR.DATE_BALANCE = CONVERT(DATETIME, FLOOR(CONVERT(MONEY,D.DATE_TO)))
                      AND GC2G.ID_GOODS_CLASSIFIER = DI.ID_GOODS_CLASSIFIER)
    GROUP BY ID_GOODS, CONTRACTOR_NAME, ID_GOODS_CLASSIFIER, GOODS_NAME, PRODUCER_NAME
    HAVING SUM(DI.QTY_REMAIN)<= @QTY_MIN 
    ORDER BY CASE WHEN NULLIF(@SORT,1) IS NULL THEN MAX(DI.LAST_SUPPLIER) END,DI.GOODS_NAME

END
ELSE 
    SELECT 
        CONTRACTOR_NAME,
        ID_GOODS,
        ID_GOODS_GLOBAL,
        ID_GOODS_CLASSIFIER = NULL,
        GOODS_NAME,
        PRODUCER_NAME,
        QTY_REMAIN,
        QTY_MIN,
        LAST_PRICE_SAL,
        LAST_PRICE_SUP,
        LAST_SUPPLIER,
        DELETED = CONVERT(INT, DELETED),
        LAST_LOT_DATE
    FROM #DEFECTURA
    ORDER BY CASE WHEN NULLIF(@SORT,1) IS NULL THEN LAST_SUPPLIER END, GOODS_NAME

RETURN
GO

--exec REP_DEFECTURA_EX @xmlParam = N'<XML><QTY_MIN>20</QTY_MIN><SORT>0</SORT><DATE>2008-09-26T00:00:00.000</DATE><DATE_FROM>2008-09-26T00:00:00.000</DATE_FROM><OA_ONLY>0</OA_ONLY><USE_GOODS_REPORT_NAME>0</USE_GOODS_REPORT_NAME><IS_ES>0</IS_ES><ID_STORE>154</ID_STORE><ID_USER>82380829-c817-486f-801d-7373f2d688e2</ID_USER></XML>'