
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF OBJECT_ID(N'DBO.UTL_BAD_PRICE_AFTER_DISASSEMBLING') IS NULL EXEC(N'CREATE PROCEDURE DBO.UTL_BAD_PRICE_AFTER_DISASSEMBLING AS RETURN')
GO
ALTER PROCEDURE [dbo].[UTL_BAD_PRICE_AFTER_DISASSEMBLING] 
    @OPTION VARCHAR(8) = NULL
AS

-- проверка на правильность цен поставщика после разукомплектации

SELECT 
    LCH.ID_LOT,
    LCH.ID_GOODS,
    LCH.LOT_NAME, 
	KOF_PRICE = LCH.PRICE_SUP/LPAR.PRICE_SUP,
	KOF_SCALE = DBO.FN_SCALE_KOF(LCH.ID_SCALING_RATIO, LPAR.ID_SCALING_RATIO),
    LCH.PRICE_SUP AS PRICE_SUP_CH,
    LPAR.PRICE_SUP AS PRICE_SUP_PAR,
    LCH.ID_SCALING_RATIO AS ID_SCALING_RATIO_CH, 
    LPAR.ID_SCALING_RATIO AS ID_SCALING_RATIO_PAR
INTO #BAD_CHILD_PRICE 
FROM LOT LCH
    INNER JOIN LOT LPAR ON LPAR.ID_LOT_GLOBAL = LCH.ID_PARENT
WHERE 0.02 < CASE WHEN LPAR.PRICE_SUP = 0 THEN 0
	ELSE ABS(LCH.PRICE_SUP/LPAR.PRICE_SUP - DBO.FN_SCALE_KOF(LCH.ID_SCALING_RATIO, LPAR.ID_SCALING_RATIO)) 
    END 

IF @@ROWCOUNT <> 0 BEGIN
    SELECT 
        G.NAME AS GOOD_NAME,
        T.LOT_NAME, 
        PRICE_SUP_PAR = PRICE_SUP_PAR * SRPAR.DENOMINATOR / SRPAR.NUMERATOR,
        SCALING_RATIO_PAR = CAST(SRPAR.NUMERATOR AS VARCHAR(10)) + '/' + CAST(SRPAR.DENOMINATOR AS VARCHAR(10)),
        T.PRICE_SUP_CH,
        SCALING_RATIO_CH = CAST(SRCH.NUMERATOR AS VARCHAR(10)) + '/' + CAST(SRCH.DENOMINATOR AS VARCHAR(10)),
        SCALING_RATIO_PAR_K = CAST(SRPAR.DENOMINATOR AS MONEY) / SRPAR.NUMERATOR,
        SCALING_RATIO_CH_K = CAST(SRCH.DENOMINATOR AS MONEY) / SRCH.NUMERATOR
    INTO #BAD_CHILD_PRICE_INFO
    FROM #BAD_CHILD_PRICE T
        INNER JOIN GOODS G ON T.ID_GOODS = G.ID_GOODS
        INNER JOIN SCALING_RATIO SRCH ON T.ID_SCALING_RATIO_CH = SRCH.ID_SCALING_RATIO
        INNER JOIN SCALING_RATIO SRPAR ON T.ID_SCALING_RATIO_PAR = SRPAR.ID_SCALING_RATIO

    SELECT '-----------------------------------------------------------------------------'
	SELECT 'Проверка на правильность цены поставщика партий после разукомплектации:'
    SELECT 'Товар', 'Мнемокод партии', 'Цена партии-предка', 'Коэф.предка', 'Цена партии-потомка', 'Коэф.потомка', 'Цена партии-потомка ожидаемая'
    SELECT 
        GOOD_NAME,
        LOT_NAME, 
        PRICE_SUP_PAR,
        SCALING_RATIO_PAR,
        PRICE_SUP_CH,
        SCALING_RATIO_CH,
        PRICE_SUP_CH_EXP = ROUND(PRICE_SUP_PAR / SCALING_RATIO_PAR_K / SCALING_RATIO_CH_K, 2)
    FROM #BAD_CHILD_PRICE_INFO
    ORDER BY GOOD_NAME, LOT_NAME
END
ELSE BEGIN
    SELECT '-----------------------------------------------------------------------------'
	SELECT 'Проверка на правильность цены поставщика партий после разукомплектации:'
    SELECT 'Ошибок не обнаружено'
END
RETURN
GO
/*
EXEC UTL_BAD_PRICE_AFTER_DISASSEMBLING
*/
/****** Object:  StoredProcedure [dbo].[UTL_CHECK_CASH_SESSION_SUM]    Script Date: 08/25/2011 11:33:42 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO
IF OBJECT_ID(N'DBO.UTL_CHECK_CASH_SESSION_SUM') IS NULL EXEC(N'CREATE PROCEDURE DBO.UTL_CHECK_CASH_SESSION_SUM AS RETURN')
GO
ALTER PROCEDURE [dbo].[UTL_CHECK_CASH_SESSION_SUM] 
	@OPTION VARCHAR(8) = NULL
AS
/*    Проверка/исправление сумм кассовых смен в DOC_MOVEMENT
*/
DECLARE @ROWCOUNT INT
IF OBJECT_ID('TEMPDB..#T1') IS NOT NULL DROP TABLE #T1
-- отобрать смены с некорректными суммами в DOC_MOVEMENT
-- SET NOCOUNT OFF
SELECT 
	CS.ID_CASH_SESSION,
    CS.ID_CASH_SESSION_GLOBAL,
    CS.DATE_OPEN,
    CS.DATE_CLOSE,
	STATUS_TEXT = CASE CS.STATUS WHEN 0 THEN 'Открыта' WHEN 1 THEN 'Закрыта' END,
    CS.SUM_SALES,    
    DM.SUM_ACC
INTO #T1    
FROM CASH_SESSION CS 
     LEFT JOIN (SELECT ID_DOCUMENT, SUM(SUM_ACC) AS SUM_ACC
                FROM DOC_MOVEMENT 
                WHERE SIGN_OP < 0    -- сравниваются только суммы продаж
                GROUP BY ID_DOCUMENT)
    DM ON DM.ID_DOCUMENT = CS.ID_CASH_SESSION_GLOBAL
WHERE ISNULL(CS.SUM_SALES, 0) <> ISNULL(DM.SUM_ACC , 0)    

SET @ROWCOUNT = @@ROWCOUNT

IF @ROWCOUNT = 0
BEGIN
    SELECT '-----------------------------------------------------------------------------'
    SELECT 'Проверка совпадения сумм в кассовых сменах и в таблице для отчетов (DOC_MOVEMENT)'
    SELECT 'Расхождений нет'
    RETURN
END

IF ISNULL(@OPTION, '') <> 'REPAIR'
-- только показать расхождения
BEGIN
    SELECT '-----------------------------------------------------------------------------'
    SELECT 'Проверка совпадения сумм в кассовых сменах и в таблице для отчетов (DOC_MOVEMENT)'
    SELECT 'У этих кассовых смен есть расхождения в суммах:'
    SELECT 'Код сессии','Дата открытия', 'Дата закрытия', 'Статус', 'Сумма продаж в смене', 
        'Сумма продаж в DOC_MOVEMENT', 'Разницы сумм'
    SELECT 
        -- ID_CASH_SESSION_GLOBAL,    -- отладка
		ID_CASH_SESSION AS [Код сессии],
        DATE_OPEN AS [Дата открытия], DATE_CLOSE AS [Дата закрытия], STATUS_TEXT AS [Статус], 
        SUM_SALES AS [Сумма продаж в смене], 
        SUM_ACC AS [Сумма продаж в DOC_MOVEMENT],
        ISNULL(SUM_SALES, 0) - ISNULL(SUM_ACC, 0) AS DELTA
    FROM #T1
    ORDER BY DATE_OPEN
    RETURN    -- выход
END

-- пересчитать данные в DOC_MOVEMENT (работают триггеры на таблице CASH_SESSION)
EXEC USP_CONTEXT_SET_REPLICATION_CONTEXT 1

UPDATE CASH_SESSION 
SET STATUS = STATUS
WHERE ID_CASH_SESSION_GLOBAL IN (SELECT ID_CASH_SESSION_GLOBAL FROM #T1)

EXEC USP_CONTEXT_SET_REPLICATION_CONTEXT 0

SELECT '-----------------------------------------------------------------------------'
SELECT 'Проверка совпадения сумм в кассовых сменах и в таблице для отчетов (DOC_MOVEMENT)'
SELECT 'Пересчитаны суммы у ' + CAST(@ROWCOUNT AS VARCHAR(10)) + ' кассовых смен' 

RETURN
GO
/*
exec UTL_CHECK_CASH_SESSION_SUM
*/

/****** Object:  StoredProcedure [dbo].[UTL_CHECK_CHEQUE]    Script Date: 08/25/2011 12:07:40 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO
IF OBJECT_ID(N'DBO.UTL_CHECK_CHEQUE') IS NULL EXEC(N'CREATE PROCEDURE DBO.UTL_CHECK_CHEQUE AS RETURN')
GO
ALTER PROCEDURE [dbo].[UTL_CHECK_CHEQUE] 
	@OPTION VARCHAR(8) = NULL
AS
DECLARE @ROWCOUNT INT

-- 'Неправильные суммы или округление не до 2 знаков суммы по позициям чеков'
-- drop table #CHEQUE_ITEM_ERR

SELECT '------------------------------------------------------------'
SELECT 'Проверка кассовых чеков и смен:'
SELECT 'Неправильные суммы или округление не до 2 знаков суммы по позициям чеков'

SELECT ID_CHEQUE_GLOBAL, ID_CHEQUE_ITEM, QUANTITY, PRICE, SUMM_DISCOUNT, SUMM
INTO #CHEQUE_ITEM_ERR FROM CHEQUE_ITEM
WHERE SUMM <> ROUND(SUMM, 2)
   OR SUMM_DISCOUNT <> ROUND(SUMM_DISCOUNT, 2)
   OR SUMM <> ROUND(QUANTITY * PRICE, 2) - ROUND(SUMM_DISCOUNT, 2)

IF @@ROWCOUNT > 0 BEGIN
	IF @OPTION = 'REPAIR' BEGIN
        SELECT @ROWCOUNT = COUNT(*) FROM #CHEQUE_ITEM_ERR

		UPDATE CH1 SET CH1.PRICE = ROUND(CH1.PRICE, 2),
			CH1.SUMM_DISCOUNT = ROUND(CH1.SUMM_DISCOUNT, 2),
			CH1.SUMM = ROUND(CH1.QUANTITY * CH1.PRICE, 2) - ROUND(CH1.SUMM_DISCOUNT, 2)
		FROM CHEQUE_ITEM CH1 
            INNER JOIN #CHEQUE_ITEM_ERR CH2 ON CH1.ID_CHEQUE_ITEM = CH2.ID_CHEQUE_ITEM

        SELECT 'Исправлены неправильные суммы или округление по позициям чеков для строк чеков: ' 
            + CAST(@ROWCOUNT AS VARCHAR(10))
	END
    ELSE BEGIN
        SELECT 'Дата чека', 'Состояние', 'Код чека', 'Тип чека', 'Кол-во', 'Цена', 'Сумма скидки', 'Сумма'
    	SELECT 
            CH.DATE_CHEQUE,
            CH.DOCUMENT_STATE,
            CH.ID_CHEQUE,
            CH.CHEQUE_TYPE,
            CHI.QUANTITY, 
            CHI.PRICE, 
            CHI.SUMM_DISCOUNT, 
            CHI.SUMM 
        FROM #CHEQUE_ITEM_ERR CHI
            INNER JOIN CHEQUE CH ON CHI.ID_CHEQUE_GLOBAL = CH.ID_CHEQUE_GLOBAL 
        ORDER BY CH.DATE_CHEQUE, CH.DOCUMENT_STATE, CH.ID_CHEQUE
    END
END
ELSE BEGIN
    SELECT 'Ошибок не обнаружено'
END
-----------------------------------------------------------------
-- 'Итог по чеку не равен сумме позиций'
-- drop table #CHEQUE
SELECT '------------------------------------------------------------'
SELECT 'Проверка кассовых чеков и смен:'
SELECT 'Итог по чеку не равен сумме позиций'

SELECT ID_CHEQUE_GLOBAL, SUM(SUMM) AS SUMM_OK, SUM(SUMM_DISCOUNT) AS SUM_DISCOUNT_OK
INTO #CHEQUE FROM CHEQUE_ITEM 
GROUP BY ID_CHEQUE_GLOBAL

SELECT CH1.ID_CHEQUE_GLOBAL, CH1.SUMM, CH1.SUM_DISCOUNT, CH2.SUMM_OK, CH2.SUM_DISCOUNT_OK
INTO #CHEQUE_ERR FROM CHEQUE CH1
LEFT JOIN #CHEQUE CH2 ON CH1.ID_CHEQUE_GLOBAL = CH2.ID_CHEQUE_GLOBAL 
WHERE CH1.SUM_DISCOUNT <> CH2.SUM_DISCOUNT_OK OR CH1.SUMM <> CH2.SUMM_OK

-- drop table #CHEQUE_ERR
SELECT @ROWCOUNT = COUNT(*) FROM #CHEQUE_ERR
IF @ROWCOUNT > 0 BEGIN
	IF @OPTION = 'REPAIR' BEGIN
		UPDATE CH1 SET CH1.SUMM = CH2.SUMM_OK,
			CH1.SUM_DISCOUNT =  CH2.SUM_DISCOUNT_OK
		FROM CHEQUE CH1 
            INNER JOIN #CHEQUE_ERR CH2 ON CH1.ID_CHEQUE_GLOBAL = CH2.ID_CHEQUE_GLOBAL 
        SELECT 'Исправлена сумма ' + CAST(@ROWCOUNT AS VARCHAR(10)) + ' чеков'
	END
    ELSE BEGIN
        SELECT 'Дата чека', 'Состояние', 'Тип чека', 'Сумма', 'Сумма скидки'
        SELECT CH.DATE_CHEQUE, CH.DOCUMENT_STATE, CH.CHEQUE_TYPE, CH.SUMM, CH.SUM_DISCOUNT
        FROM #CHEQUE_ERR T
            INNER JOIN CHEQUE CH ON T.ID_CHEQUE_GLOBAL = CH.ID_CHEQUE_GLOBAL
        ORDER BY CH.DATE_CHEQUE, CH.DOCUMENT_STATE, CH.CHEQUE_TYPE
    END
END
ELSE BEGIN
    SELECT 'Ошибок не обнаружено'
    
END
-------------------------------------------------------------------------
--  'Итог по сессии не равен сумме чеков'
SELECT '------------------------------------------------------------'
SELECT 'Проверка кассовых чеков и смен:'
SELECT 'Итог по сессии не равен сумме чеков'

-- суммы смен по чекам:
SELECT ID_CASH_SESSION_GLOBAL, 
	SUM(CASE WHEN CHEQUE_TYPE = 'SALE' THEN SUMM ELSE 0.00 END) AS SUM_SALES_OK,
	SUM(CASE WHEN CHEQUE_TYPE = 'RETURN' THEN SUMM ELSE 0.00 END) AS SUM_SALES_RETURNS_OK,
	SUM(CASE WHEN CHEQUE_TYPE = 'CASH_OUT' THEN SUMM ELSE 0.00 END) AS SUM_REQUISITIONING_OK,
	SUM(CASE WHEN CHEQUE_TYPE = 'CASH_IN' THEN SUMM ELSE 0.00 END) AS SUM_PAYMENT_OK,
	SUM(SUM_DISCOUNT) AS SUM_DISCOUNT_OK,
	SUM(CASE WHEN CHEQUE_TYPE IN ('SALE') THEN 1 ELSE 0 END) AS QUANTITY_SALES_OK,
	SUM(CASE WHEN CHEQUE_TYPE IN ('RETURN') THEN 1 ELSE 0 END) AS QUANTITY_SALES_RETURNS_OK,
	SUM(CASE WHEN CHEQUE_TYPE IN ('CASH_IN') THEN 1 ELSE 0 END) AS QUANTITY_PAYMENT_OK,
	SUM(CASE WHEN CHEQUE_TYPE IN ('CASH_OUT') THEN 1 ELSE 0 END) AS QUANTITY_REQUISITIONING_OK
INTO #CASH_SESSION2 
FROM CHEQUE 
WHERE DOCUMENT_STATE = 'PROC'
GROUP BY ID_CASH_SESSION_GLOBAL

-- drop table #CASH_SESSION_ERR
SELECT 
    CS.ID_CASH_SESSION_GLOBAL, 
    CS.STATUS,
    CS.DATE_OPEN, 
    CS.DATE_CLOSE,
	CS.SUM_SALES, CS_CH.SUM_SALES_OK,
	CS.SUM_SALES_RETURNS, CS_CH.SUM_SALES_RETURNS_OK,
	CS.SUM_REQUISITIONING, CS_CH.SUM_REQUISITIONING_OK,
	CS.SUM_PAYMENT, CS_CH.SUM_PAYMENT_OK,
	CS.SUM_DISCOUNT, CS_CH.SUM_DISCOUNT_OK,
	CS.QUANTITY_SALES, CS_CH.QUANTITY_SALES_OK,
	CS.QUANTITY_SALES_RETURNS, CS_CH.QUANTITY_SALES_RETURNS_OK,
	CS.QUANTITY_PAYMENT, CS_CH.QUANTITY_PAYMENT_OK,
	CS.QUANTITY_REQUISITIONING, CS_CH.QUANTITY_REQUISITIONING_OK
INTO #CASH_SESSION_ERR 
FROM CASH_SESSION CS
    LEFT JOIN #CASH_SESSION2 CS_CH ON CS.ID_CASH_SESSION_GLOBAL = CS_CH.ID_CASH_SESSION_GLOBAL 
WHERE 
       ISNULL(CS.SUM_SALES, 0) <> ISNULL(CS_CH.SUM_SALES_OK, 0)
	OR ISNULL(CS.SUM_SALES_RETURNS, 0) <> ISNULL(CS_CH.SUM_SALES_RETURNS_OK, 0)
	OR ISNULL(CS.SUM_REQUISITIONING, 0) <> ISNULL(CS_CH.SUM_REQUISITIONING_OK, 0)
	OR ISNULL(CS.SUM_PAYMENT, 0) <> ISNULL(CS_CH.SUM_PAYMENT_OK, 0)
	OR ISNULL(CS.SUM_DISCOUNT, 0) <> ISNULL(CS_CH.SUM_DISCOUNT_OK, 0)
	OR ISNULL(CS.QUANTITY_SALES, 0) <> ISNULL(CS_CH.QUANTITY_SALES_OK, 0)
	OR ISNULL(CS.QUANTITY_SALES_RETURNS, 0) <> ISNULL(CS_CH.QUANTITY_SALES_RETURNS_OK, 0)
	OR ISNULL(CS.QUANTITY_PAYMENT, 0) <> ISNULL(CS_CH.QUANTITY_PAYMENT_OK, 0)
	OR ISNULL(CS.QUANTITY_REQUISITIONING, 0) <> ISNULL(CS_CH.QUANTITY_REQUISITIONING_OK, 0)

SELECT @ROWCOUNT = COUNT(*) FROM #CASH_SESSION_ERR
-- UTL_CHECK_CHEQUE 'REPAIR'
IF @ROWCOUNT > 0 BEGIN
	-- SELECT * FROM #CASH_SESSION_ERR
	IF @OPTION = 'REPAIR' BEGIN
		UPDATE CS SET 
            CS.SUM_SALES = ISNULL(CS_CH.SUM_SALES_OK, 0),
			CS.SUM_SALES_RETURNS =  ISNULL(CS_CH.SUM_SALES_RETURNS_OK, 0),
			CS.SUM_REQUISITIONING =  ISNULL(CS_CH.SUM_REQUISITIONING, 0),
			CS.SUM_PAYMENT =  ISNULL(CS_CH.SUM_PAYMENT_OK, 0),
			CS.SUM_DISCOUNT =  ISNULL(CS_CH.SUM_DISCOUNT_OK, 0),
			CS.QUANTITY_SALES =  ISNULL(CS_CH.QUANTITY_SALES_OK, 0),
            CS.QUANTITY_SALES_RETURNS = ISNULL(CS_CH.QUANTITY_SALES_RETURNS_OK, 0),
            CS.QUANTITY_PAYMENT = ISNULL(CS_CH.QUANTITY_PAYMENT_OK, 0),
            CS.QUANTITY_REQUISITIONING = ISNULL(CS_CH.QUANTITY_REQUISITIONING_OK, 0)
		FROM CASH_SESSION CS 
            INNER JOIN #CASH_SESSION_ERR CS_CH ON CS.ID_CASH_SESSION_GLOBAL = CS_CH.ID_CASH_SESSION_GLOBAL 
        SELECT 'Исправлено ' + CAST(@ROWCOUNT AS VARCHAR(10)) + ' кассовых смен'
    END
    ELSE BEGIN
        SELECT 'У этих кассовых смен итог по смене не равен сумме чеков'
        SELECT 'Дата открытия', 'Дата закрытия', 'Состояние', 'Продажа', 'Продажа по чекам', 'Возврат',  'Возврат по чекам', 'Скидка', 'Скидка по чекам'
        SELECT 
            -- ID_CASH_SESSION_GLOBAL,        
            DATE_OPEN,
            ISNULL(DATE_CLOSE, ''),
            CASE WHEN STATUS = 1 THEN 'Закрыта' ELSE 'Открыта' END,
            SUM_SALES, 
            SUM_SALES_OK,
			SUM_SALES_RETURNS, 
			SUM_SALES_RETURNS_OK,           
            -- SUM_REQUISITIONING, SUM_REQUISITIONING_OK,
            -- SUM_PAYMENT, SUM_PAYMENT_OK, 
            SUM_DISCOUNT, 
            SUM_DISCOUNT_OK
            -- QUANTITY_SALES, QUANTITY_SALES_OK,
            -- QUANTITY_SALES_RETURNS, QUANTITY_SALES_RETURNS_OK,
            -- QUANTITY_PAYMENT, QUANTITY_PAYMENT_OK,
            -- QUANTITY_REQUISITIONING, QUANTITY_REQUISITIONING_OK
		FROM #CASH_SESSION_ERR 
        ORDER BY DATE_OPEN
	END
END
ELSE BEGIN
    SELECT 'Ошибок не обнаружено'
END

---------------------------------------------------------------------
-- Проверка правильности списания по чекам
-- здесь три проверки
SELECT '-------------------------------------------------------------'
SELECT 'Проверка кассовых чеков и смен:'
SELECT 'Проверка правильности списания по чекам (по товарам, услуги исключаются):'
SELECT 'Товар не совпадает в партии строки чека и в строке чека'

SELECT 	
    CASE 
		WHEN CI.ID_GOODS <> LOT.ID_GOODS THEN CAST('G' AS VARCHAR(10)) 
		WHEN CI.ID_SCALING_RATIO <> LOT.ID_SCALING_RATIO THEN CAST('SR' AS VARCHAR(10)) 
		WHEN ABS(CI.PRICE  - LOT.PRICE_SAL) > 0.05 THEN CAST('PRICE' AS VARCHAR(10))
		ELSE CAST(NULL AS VARCHAR(10))
    END AS REASON,
	C.ID_CHEQUE, C.DATE_CHEQUE, C.CHEQUE_TYPE, C.DOCUMENT_STATE, C.MNEMOCODE,
	LOT.PRICE_SAL, CI.PRICE, CI.QUANTITY,  CI.SUMM_DISCOUNT, CI.SUMM,
	LOT.ID_GOODS AS LOT_ID_GOODS, G1.NAME AS LOT_GOODS_NAME, 
	CI.ID_GOODS AS CHK_ID_GOODS, G2.NAME AS CHK_GOODS_NAME,
    CI.ID_SCALING_RATIO AS ID_SCALING_RATIO_CH, LOT.ID_SCALING_RATIO AS ID_SCALING_RATIO_LM
INTO #TEST_CHEQUE 
FROM LOT_MOVEMENT LM
    INNER JOIN LOT ON LOT.ID_LOT_GLOBAL = LM.ID_LOT_GLOBAL
    INNER JOIN CHEQUE_ITEM CI ON CI.ID_CHEQUE_ITEM_GLOBAL = LM.ID_DOCUMENT_ITEM
    INNER JOIN CHEQUE C ON C.ID_CHEQUE_GLOBAL = CI.ID_CHEQUE_GLOBAL
    LEFT JOIN GOODS G1 ON G1.ID_GOODS = LOT.ID_GOODS
    LEFT JOIN GOODS G2 ON G2.ID_GOODS = CI.ID_GOODS
WHERE CI.ID_GOODS IS NOT NULL
	AND 
	  (CI.ID_GOODS <> LOT.ID_GOODS
	OR CI.ID_SCALING_RATIO <> LOT.ID_SCALING_RATIO
	OR ABS(CI.PRICE  - LOT.PRICE_SAL) > 0.05)
---------------------------
SELECT @ROWCOUNT = COUNT(*) FROM #TEST_CHEQUE WHERE REASON = 'G'
IF @ROWCOUNT > 0 BEGIN
    SELECT 'Код чека', 'Дата чека', 'Тип чека', 'Цена', 'Кол-во', 'Товар в строке чека', 'Товар в проводке строки чека'
	SELECT ID_CHEQUE, DATE_CHEQUE, CHEQUE_TYPE, PRICE, QUANTITY, CHK_GOODS_NAME, LOT_GOODS_NAME
    FROM #TEST_CHEQUE
    WHERE REASON = 'G'
    ORDER BY DATE_CHEQUE, CHEQUE_TYPE, CHK_GOODS_NAME
END
ELSE BEGIN
    SELECT 'Ошибок не обнаружено'
END

---------------------------
SELECT '-------------------------------------------------------------'
SELECT 'Проверка кассовых чеков и смен:'
SELECT 'Проверка правильности списания по чекам (по товарам, услуги исключаются):'
SELECT 'Коэффициент деления не совпадает в партии строки чека и в строке чека'

SELECT @ROWCOUNT = COUNT(*) FROM #TEST_CHEQUE WHERE REASON = 'SR'
IF @ROWCOUNT > 0 BEGIN
    SELECT 'Код чека', 'Дата чека', 'Тип чека', 'Цена', 'Кол-во', 'Коэффициент в строке чека', 'Коэффициент в проводке строки чека'
	SELECT T.ID_CHEQUE, T.DATE_CHEQUE, T.CHEQUE_TYPE, T.PRICE, T.QUANTITY, 
        SCALING_RATIO_CH = (SELECT TOP 1 CAST(SR.NUMERATOR AS VARCHAR(10)) + '/' + CAST(SR.DENOMINATOR AS VARCHAR(10))
                            FROM SCALING_RATIO SR WHERE SR.ID_SCALING_RATIO = T.ID_SCALING_RATIO_CH),
        SCALING_RATIO_LM = (SELECT TOP 1 CAST(SR.NUMERATOR AS VARCHAR(10)) + '/' + CAST(SR.DENOMINATOR AS VARCHAR(10))
                            FROM SCALING_RATIO SR WHERE SR.ID_SCALING_RATIO = T.ID_SCALING_RATIO_LM)
    FROM #TEST_CHEQUE T
    WHERE REASON = 'SR'
    ORDER BY DATE_CHEQUE, CHEQUE_TYPE, CHK_GOODS_NAME
END
ELSE BEGIN
    SELECT 'Ошибок не обнаружено'
END
---------------------------
SELECT '-------------------------------------------------------------'
SELECT 'Проверка кассовых чеков и смен:'
SELECT 'Проверка правильности списания по чекам (по товарам, услуги исключаются):'
SELECT 'Цена продажи не совпадает в партии чека и в строках чека'

SELECT @ROWCOUNT = COUNT(*) FROM #TEST_CHEQUE WHERE REASON = 'PRICE'
IF @ROWCOUNT > 0 BEGIN
    SELECT 'Код чека', 'Дата чека', 'Тип чека', 'Цена в строке чека', 'Кол-во', 'Цена в партии'
	SELECT T.ID_CHEQUE, T.DATE_CHEQUE, T.CHEQUE_TYPE, T.PRICE, T.QUANTITY, T.PRICE_SAL
    FROM #TEST_CHEQUE T
    WHERE REASON = 'PRICE'
    ORDER BY DATE_CHEQUE, CHEQUE_TYPE, CHK_GOODS_NAME
END
ELSE BEGIN
    SELECT 'Ошибок не обнаружено'
END
---------------------------------------------------------------------
-- 'Время закрытия сессии раньше времени последнего чека либо время открытия сессии позже времени первого чека:'
SELECT '-----------------------------------------------------------------------------'
SELECT 'Проверка кассовых чеков и смен:'
SELECT 'Время закрытия сессии раньше времени последнего чека либо время открытия сессии позже времени первого чека:'

SELECT CH3.ID_CHEQUE_GLOBAL, CS.ID_CASH_SESSION_GLOBAL, CS.DATE_OPEN, CS.DATE_CLOSE, CH3.DATE_CHEQUE
INTO #CHEQUE3 FROM CASH_SESSION CS
INNER JOIN CHEQUE CH3 ON CH3.ID_CASH_SESSION_GLOBAL = CS.ID_CASH_SESSION_GLOBAL
WHERE CS.DATE_CLOSE IS NOT NULL
    AND (CS.DATE_CLOSE < CH3.DATE_CHEQUE OR CS.DATE_OPEN > CH3.DATE_CHEQUE)

IF @@ROWCOUNT > 0 BEGIN
	IF @OPTION = 'REPAIR' BEGIN
		UPDATE CHEQUE SET CHEQUE.DATE_CHEQUE = CS.DATE_CLOSE
        FROM CASH_SESSION CS
        INNER JOIN #CHEQUE3 CH3 ON CH3.ID_CASH_SESSION_GLOBAL = CS.ID_CASH_SESSION_GLOBAL
		INNER JOIN CHEQUE ON CHEQUE.ID_CHEQUE_GLOBAL = CH3.ID_CHEQUE_GLOBAL
		WHERE
			CS.DATE_CLOSE < CH3.DATE_CHEQUE

		UPDATE CHEQUE SET CHEQUE.DATE_CHEQUE = CS.DATE_OPEN
        FROM CASH_SESSION CS
        INNER JOIN #CHEQUE3 CH3 ON CH3.ID_CASH_SESSION_GLOBAL = CS.ID_CASH_SESSION_GLOBAL
		INNER JOIN CHEQUE ON CHEQUE.ID_CHEQUE_GLOBAL = CH3.ID_CHEQUE_GLOBAL
		WHERE
			CS.DATE_OPEN > CH3.DATE_CHEQUE

		SELECT @ROWCOUNT = COUNT(*) FROM #CHEQUE3 
        SELECT 'Исправлена дата у ' + CAST(@ROWCOUNT AS VARCHAR(10)) + ' чеков' 
    END
    ELSE BEGIN     
        SELECT 'Дата открытия', 'Дата закрытия', 'Дата чека'
        SELECT DATE_OPEN, DATE_CLOSE, DATE_CHEQUE
        FROM #CHEQUE3
    END
END
ELSE BEGIN
    SELECT 'Ошибок не обнаружено'   
END
---------------------------------------------------------------------
-- DROP TABLE #CHEQUE4
SELECT '-----------------------------------------------------------------------------'
SELECT 'Проверка кассовых чеков и смен:'
SELECT 'Проводки по кассовым сменам принадлежат другой смене (только по товарам)'
SELECT '(LOT_MOVEMENT.ID_DOCUMENT_ITEM = CHEQUE_ITEM.ID_CHEQUE_ITEM_GLOBAL и LOT_MOVEMENT.ID_DOCUMENT <> CHEQUE.ID_CASH_SESSION_GLOBAL)'

SELECT DOC.ID_CASH_SESSION_GLOBAL, LM.ID_DOCUMENT, LM.ID_LOT_MOVEMENT
INTO #CHEQUE4 
FROM LOT_MOVEMENT LM
	INNER JOIN CHEQUE_ITEM ITEM ON ITEM.ID_CHEQUE_ITEM_GLOBAL = LM.ID_DOCUMENT_ITEM
	INNER JOIN CHEQUE DOC ON DOC.ID_CHEQUE_GLOBAL = ITEM.ID_CHEQUE_GLOBAL
WHERE LM.ID_TABLE = 19 AND LM.ID_DOCUMENT <> DOC.ID_CASH_SESSION_GLOBAL

SELECT @ROWCOUNT = COUNT(*) FROM #CHEQUE4

IF @ROWCOUNT > 0 BEGIN
	IF @OPTION = 'REPAIR' BEGIN
		UPDATE LM SET LM.ID_DOCUMENT = CH4.ID_CASH_SESSION_GLOBAL
        FROM LOT_MOVEMENT LM
        INNER JOIN #CHEQUE4 CH4 ON CH4.ID_LOT_MOVEMENT = LM.ID_LOT_MOVEMENT
    END
    ELSE BEGIN
        SELECT 'Кассовая смена', 'Склад'
        SELECT 
            ['КАС.СМЕНА'] = CS1.MNEMOCODE + CONVERT(VARCHAR(10), CS1.DATE_OPEN, 121),
            ['ПО СКЛАДУ'] = CS2.MNEMOCODE + CONVERT(VARCHAR(10), CS2.DATE_OPEN, 121)
        FROM #CHEQUE4 CH4
            LEFT JOIN CASH_SESSION CS1 ON CS1.ID_CASH_SESSION_GLOBAL = CH4.ID_CASH_SESSION_GLOBAL
            LEFT JOIN CASH_SESSION CS2 ON CS2.ID_CASH_SESSION_GLOBAL = CH4.ID_DOCUMENT
    END
END
ELSE BEGIN
    SELECT 'Ошибок не обнаружено'
END
  
RETURN 0
GO
/*
exec UTL_CHECK_CHEQUE
*/
/****** Object:  StoredProcedure [dbo].[UTL_CHECK_CHEQUE_DOUBLE_LOT_MOVEMENT]    Script Date: 08/25/2011 13:15:21 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF OBJECT_ID(N'DBO.UTL_CHECK_CHEQUE_DOUBLE_LOT_MOVEMENT') IS NULL EXEC(N'CREATE PROCEDURE DBO.UTL_CHECK_CHEQUE_DOUBLE_LOT_MOVEMENT AS RETURN')
GO
ALTER PROCEDURE [dbo].[UTL_CHECK_CHEQUE_DOUBLE_LOT_MOVEMENT] 
	@OPTION VARCHAR(8) = NULL 
AS

/*  
    Проверка на дубли проводок чеков
*/
DECLARE @ROWCOUNT INT

SELECT '-----------------------------------------------------------------------------'
SELECT 'Проверка задублированных проводок чеков:'

DECLARE @TDEL TABLE(ID_LOT_MOVEMENT BIGINT)
DECLARE @T TABLE(
	ID_LOT_MOVEMENT BIGINT,
	ID_LOT_GLOBAL	UNIQUEIDENTIFIER,
	DATE_OP	DATETIME,
	CODE_OP	VARCHAR(16),
	QUANTITY_ADD	MONEY,
	QUANTITY_SUB	MONEY,
	QUANTITY_RES	MONEY,
	SVAT_SUP	MONEY,
	SUM_SUP	MONEY,
	DISCOUNT_ACC	MONEY,
	SVAT_ACC	MONEY,
	SUM_ACC	MONEY,
	ID_TABLE	BIGINT,
	ID_DOCUMENT	UNIQUEIDENTIFIER,
	ID_DOCUMENT_ITEM	UNIQUEIDENTIFIER)

-- это проводки из числа дублей, которые должны остаться
INSERT @T(ID_LOT_MOVEMENT,
	   ID_LOT_GLOBAL, DATE_OP, CODE_OP, QUANTITY_ADD, QUANTITY_SUB, QUANTITY_RES,
	   SVAT_SUP, SUM_SUP, DISCOUNT_ACC, SVAT_ACC, SUM_ACC, ID_TABLE, ID_DOCUMENT, ID_DOCUMENT_ITEM)
SELECT MIN(ID_LOT_MOVEMENT) AS ID_LOT_MOVEMENT,
	   ID_LOT_GLOBAL, DATE_OP, CODE_OP, QUANTITY_ADD, QUANTITY_SUB, QUANTITY_RES,
	   SVAT_SUP, SUM_SUP, DISCOUNT_ACC, SVAT_ACC, SUM_ACC, ID_TABLE, ID_DOCUMENT, ID_DOCUMENT_ITEM
FROM LOT_MOVEMENT
WHERE ID_TABLE = 19
GROUP BY ID_LOT_GLOBAL, DATE_OP, CODE_OP, QUANTITY_ADD, QUANTITY_SUB, QUANTITY_RES,
	SVAT_SUP, SUM_SUP, DISCOUNT_ACC, SVAT_ACC, SUM_ACC, ID_TABLE, ID_DOCUMENT, ID_DOCUMENT_ITEM
HAVING COUNT(*) > 1

SET @ROWCOUNT = @@ROWCOUNT
IF @ROWCOUNT = 0 BEGIN
	SELECT 'Нет лишних проводок чеков'
	RETURN
END

IF @OPTION = 'REPAIR' AND @ROWCOUNT > 0 BEGIN
	-- это проводки-дубли, которые нужно удалить
	INSERT @TDEL(LM.ID_LOT_MOVEMENT)
	SELECT LM.ID_LOT_MOVEMENT
	FROM LOT_MOVEMENT LM
	WHERE EXISTS(
		SELECT * FROM @T T
		WHERE LM.ID_LOT_GLOBAL = T.ID_LOT_GLOBAL AND 
			  LM.DATE_OP = T.DATE_OP AND LM.CODE_OP = T.CODE_OP AND
			  LM.QUANTITY_ADD = T.QUANTITY_ADD AND LM.QUANTITY_SUB = T.QUANTITY_SUB AND 
			  LM.QUANTITY_RES = T.QUANTITY_RES AND
		      LM.SVAT_SUP = T.SVAT_SUP AND LM.SUM_SUP = T.SUM_SUP AND 
			  LM.DISCOUNT_ACC = T.DISCOUNT_ACC AND LM.SVAT_ACC = T.SVAT_ACC AND LM.SUM_ACC = T.SUM_ACC AND 
			  LM.ID_TABLE = T.ID_TABLE AND LM.ID_DOCUMENT = T.ID_DOCUMENT AND LM.ID_DOCUMENT_ITEM = T.ID_DOCUMENT_ITEM
	)
		AND NOT EXISTS(SELECT * FROM @T T2 WHERE LM.ID_LOT_MOVEMENT = T2.ID_LOT_MOVEMENT)
END

IF @OPTION = 'REPAIR' BEGIN
	IF @ROWCOUNT > 0 BEGIN
	
		DELETE LM FROM LOT_MOVEMENT LM
		WHERE EXISTS(SELECT * FROM @TDEL T WHERE LM.ID_LOT_MOVEMENT = T.ID_LOT_MOVEMENT)
		SET @ROWCOUNT = @@ROWCOUNT
		SELECT 'Удалено лишних проводок: ' + CAST(@ROWCOUNT AS VARCHAR(10))
	END
END
ELSE BEGIN
    SELECT 'Имеются лишние проводоки для строк чеков: ' + CAST(@ROWCOUNT AS VARCHAR(10))
END

RETURN
GO
/*
EXEC [dbo].[UTL_CHECK_CHEQUE_DOUBLE_LOT_MOVEMENT] 
*/



/****** Object:  StoredProcedure [dbo].[UTL_CHECK_CHEQUE_LOT_MOVEMENT]    Script Date: 08/25/2011 12:24:20 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO
IF OBJECT_ID(N'DBO.UTL_CHECK_CHEQUE_LOT_MOVEMENT') IS NULL EXEC(N'CREATE PROCEDURE DBO.UTL_CHECK_CHEQUE_LOT_MOVEMENT AS RETURN')
GO
ALTER PROCEDURE [dbo].[UTL_CHECK_CHEQUE_LOT_MOVEMENT] 
	@OPTION VARCHAR(8) = NULL
AS
DECLARE @ROWCOUNT INT, 
    @ID_CHEQUE_GLOBAL UNIQUEIDENTIFIER,
    @RET_VAL INT
IF OBJECT_ID('TEMPDB..#CHEQUE') IS NOT NULL DROP TABLE #CHEQUE
-- 'Суммы в строке чека не равны суммам в проводке строки:'
-- по товарам
SELECT DISTINCT
    CH_IT.ID_CHEQUE_GLOBAL,
    CH_IT.SUMM_DISCOUNT, 
    LM.DISCOUNT_ACC,
    CH_IT.SUMM, 
    LM.SUM_ACC,
    CH_IT.ID_GOODS,
	CAST(NULL AS UNIQUEIDENTIFIER) AS ID_SERVICE_4_SALE,
	CAST('G' AS CHAR(1)) AS GOODS_OR_SERVICE
INTO #CHEQUE     
FROM CHEQUE_ITEM CH_IT 
    INNER JOIN CHEQUE CH ON CH_IT.ID_CHEQUE_GLOBAL = CH.ID_CHEQUE_GLOBAL
    LEFT JOIN LOT_MOVEMENT LM ON CH_IT.ID_CHEQUE_ITEM_GLOBAL = LM.ID_DOCUMENT_ITEM
WHERE CH.DOCUMENT_STATE = 'PROC'
	AND CH_IT.ID_GOODS IS NOT NULL    
    AND
      (ISNULL(CH_IT.SUMM, 0) <> ISNULL(LM.SUM_ACC, 0) OR
       ISNULL(CH_IT.SUMM_DISCOUNT, 0) <> ISNULL(LM.DISCOUNT_ACC, 0))

-- по услугам
INSERT #CHEQUE(
    ID_CHEQUE_GLOBAL,
    SUMM_DISCOUNT, 
    DISCOUNT_ACC,
    SUMM, 
    SUM_ACC,
    ID_GOODS,
	ID_SERVICE_4_SALE,
	GOODS_OR_SERVICE
	)
SELECT DISTINCT
    CH_IT.ID_CHEQUE_GLOBAL,
    CH_IT.SUMM_DISCOUNT, 
    LM.DISCOUNT_ACC,
    CH_IT.SUMM, 
    LM.SUM_ACC,
	NULL,
    CH_IT.ID_LOT_GLOBAL,	-- это код услуги
	'S'
FROM CHEQUE_ITEM CH_IT
    INNER JOIN CHEQUE CH ON CH_IT.ID_CHEQUE_GLOBAL = CH.ID_CHEQUE_GLOBAL
    LEFT JOIN SERVICE_4_SALE_MOVEMENT LM ON CH_IT.ID_CHEQUE_ITEM_GLOBAL = LM.ID_DOCUMENT_ITEM
WHERE CH.DOCUMENT_STATE = 'PROC'
	AND CH_IT.ID_GOODS IS NULL    
    AND
      (ISNULL(CH_IT.SUMM, 0) <> ISNULL(LM.SUM_ACC, 0) OR
       ISNULL(CH_IT.SUMM_DISCOUNT, 0) <> ISNULL(LM.DISCOUNT_ACC, 0))

SELECT @ROWCOUNT = COUNT(*) FROM #CHEQUE

SELECT '-----------------------------------------------------------------------------'
SELECT 'Проверка кассовых чеков и смен:'
SELECT 'Суммы в строке чека не равны суммам в проводке строки (по товарам и услугам):'

IF @ROWCOUNT > 0 BEGIN
	IF @OPTION = 'REPAIR' BEGIN
/*
        UPDATE 
            LM SET LM.SUM_ACC = ROUND(CH_IT.SUMM, 2),
            LM.DISCOUNT_ACC = ROUND(CH_IT.SUMM_DISCOUNT, 2)
        FROM LOT_MOVEMENT LM
            INNER JOIN CHEQUE_ITEM CH_IT ON CH_IT.ID_CHEQUE_ITEM_GLOBAL = LM.ID_DOCUMENT_ITEM
        WHERE CH_IT.SUMM <> LM.SUM_ACC
           OR CH_IT.SUMM_DISCOUNT <> LM.DISCOUNT_ACC
*/
        DECLARE CUR CURSOR LOCAL READ_ONLY FAST_FORWARD
        FOR SELECT DISTINCT ID_CHEQUE_GLOBAL           
            FROM #CHEQUE
        OPEN CUR
        WHILE 1 = 1 
        BEGIN
            FETCH NEXT FROM CUR INTO @ID_CHEQUE_GLOBAL
            IF @@FETCH_STATUS <> 0 BREAK
            IF @@TRANCOUNT = 0 BEGIN TRAN
                SET @RET_VAL = 0
                EXEC @RET_VAL = USP_CHEQUE_UNPROC @ID_CHEQUE_GLOBAL, 0
                IF @@ERROR <> 0 OR @RET_VAL <> 0 GOTO ERR
                -- провести чек
                SET @RET_VAL = 0
                EXEC @RET_VAL = USP_CHEQUE_PROCESS @ID_CHEQUE_GLOBAL, 0
                IF @@ERROR <> 0 OR @RET_VAL <> 0 GOTO ERR
            IF @@TRANCOUNT > 0 COMMIT
            GOTO NEXT_ROW
            ERR:
                IF @@TRANCOUNT > 0 ROLLBACK
            NEXT_ROW:
        END
        CLOSE CUR
        DEALLOCATE CUR

        SELECT 'Исправлены (перепроведены) ' + CAST(@ROWCOUNT AS VARCHAR(10)) + ' чеков'
    END
    ELSE BEGIN
		SELECT 'по товарам:'
        SELECT 'Код чека', 'Дата чека', 'Состояние', 'Товар в строке чека', 'Сумма в чеке', 'Сумма в проводке', 'Скидка в чеке', 'Скидка в проводке'
        SELECT CH.ID_CHEQUE,
			CH.DATE_CHEQUE,
			CH.DOCUMENT_STATE,
			G.NAME AS GOODS_NAME, 
            T.SUMM,
            T.SUM_ACC,
            T.SUMM_DISCOUNT,
            T.DISCOUNT_ACC
        FROM #CHEQUE T
            INNER JOIN CHEQUE CH ON CH.ID_CHEQUE_GLOBAL = T.ID_CHEQUE_GLOBAL
            INNER JOIN GOODS G ON G.ID_GOODS = T.ID_GOODS
        ORDER BY DATE_CHEQUE, G.NAME

		SELECT 'по услугам:'
        SELECT 'Код чека', 'Дата чека', 'Состояние', 'Услуга в строке чека', 'Сумма в чеке', 'Сумма в проводке', 'Скидка в чеке', 'Скидка в проводке'
        SELECT	CH.ID_CHEQUE,
				CH.DATE_CHEQUE,
				CH.DOCUMENT_STATE,
				S4S.NAME AS SERVICE_NAME, 
                T.SUMM,
                T.SUM_ACC,
                T.SUMM_DISCOUNT,
                T.DISCOUNT_ACC
        FROM #CHEQUE T
            INNER JOIN CHEQUE CH ON CH.ID_CHEQUE_GLOBAL = T.ID_CHEQUE_GLOBAL
            INNER JOIN SERVICE_4_SALE S4S ON S4S.ID_SERVICE_4_SALE = T.ID_SERVICE_4_SALE
        ORDER BY CH.DATE_CHEQUE, S4S.NAME
    END
END
ELSE BEGIN
    SELECT 'Ошибок не обнаружено'
END

RETURN
GO 
/*
exec UTL_CHECK_CHEQUE_LOT_MOVEMENT
*/
/****** Object:  StoredProcedure [dbo].[UTL_CHECK_CHEQUE_SR_GOODS]    Script Date: 08/25/2011 13:39:29 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO
IF OBJECT_ID(N'DBO.UTL_CHECK_CHEQUE_SR_GOODS') IS NULL EXEC(N'CREATE PROCEDURE DBO.UTL_CHECK_CHEQUE_SR_GOODS AS RETURN')
GO
ALTER PROCEDURE [dbo].[UTL_CHECK_CHEQUE_SR_GOODS] 
	@OPTION VARCHAR(8) = NULL
AS
DECLARE @ROWCOUNT INT

SELECT '------------------------------------------------------------'
SELECT 'Товар в строке чека не совпадает с товаром партии в строке чека'
-- DROP TABLE #T_GOODS
CREATE TABLE #T_GOODS(
	ID_CHEQUE_GLOBAL UNIQUEIDENTIFIER, 
	ID_CHEQUE_ITEM_GLOBAL UNIQUEIDENTIFIER,
	ID_GOODS_CHI BIGINT,
	ID_GOODS_LOT BIGINT)

INSERT #T_GOODS(ID_CHEQUE_GLOBAL, ID_CHEQUE_ITEM_GLOBAL, ID_GOODS_CHI, ID_GOODS_LOT)
SELECT CHI.ID_CHEQUE_GLOBAL, CHI.ID_CHEQUE_ITEM_GLOBAL, CHI.ID_GOODS, L.ID_GOODS
FROM CHEQUE_ITEM CHI
    INNER JOIN LOT L ON CHI.ID_LOT_GLOBAL = L.ID_LOT_GLOBAL
WHERE CHI.ID_GOODS <> L.ID_GOODS

IF EXISTS(SELECT * FROM #T_GOODS) BEGIN
	IF ISNULL(@OPTION, '') <> 'REPAIR' BEGIN
		SELECT 'Проблемные строки чеков'
		SELECT 'Код чека', 'Дата чека', 'Сумма чека', 'Мнемокод чека', 'Товар в строке чека', 'Товар в партии строки чека'
		SELECT CH.ID_CHEQUE, CH.DATE_CHEQUE, CH.SUMM, CH.MNEMOCODE, G_CH.NAME AS G_CH_NAME, G_LOT.NAME AS G_LOT_NAME
		FROM CHEQUE CH
			INNER JOIN #T_GOODS T ON T.ID_CHEQUE_GLOBAL = CH.ID_CHEQUE_GLOBAL
			LEFT JOIN GOODS G_CH ON T.ID_GOODS_CHI = G_CH.ID_GOODS
			LEFT JOIN GOODS G_LOT ON T.ID_GOODS_LOT = G_LOT.ID_GOODS
		ORDER BY CH.DATE_CHEQUE, CH.MNEMOCODE
	END
	ELSE BEGIN
		-- исправление
		UPDATE CHI SET CHI.ID_GOODS = L.ID_GOODS
		FROM CHEQUE_ITEM CHI
			INNER JOIN LOT L ON CHI.ID_LOT_GLOBAL = L.ID_LOT_GLOBAL
			INNER JOIN #T_GOODS T ON T.ID_CHEQUE_ITEM_GLOBAL = CHI.ID_CHEQUE_ITEM_GLOBAL
		SELECT @ROWCOUNT = @@ROWCOUNT
		SELECT 'Исправлены товары (товар в строке чека исправлен на товар из партии) в строках чеков: ' + CAST(@ROWCOUNT AS VARCHAR(20))
	END
END
ELSE BEGIN
	SELECT 'Нет чеков с такой ошибкой'
END

SELECT '------------------------------------------------------------'
SELECT 'Код коэфициента деления в строке чека не совпадает с кодом коэффициента деления партии в строке чека'
-- DROP TABLE #T_SR
CREATE TABLE #T_SR(
	ID_CHEQUE_GLOBAL UNIQUEIDENTIFIER, 
	ID_CHEQUE_ITEM_GLOBAL UNIQUEIDENTIFIER,
	ID_SCALING_RATIO_CHI BIGINT,
	ID_SCALING_RATIO_LOT BIGINT,
	ID_GOODS_SR_CHI BIGINT,
	ID_GOODS_SR_LOT BIGINT,
	SR_CHI_DENOMINATOR INT,
	SR_CHI_NUMERATOR INT,
	SR_LOT_DENOMINATOR INT,
	SR_LOT_NUMERATOR INT,
    SR_NOT_EQUAL BIT)

INSERT #T_SR(ID_CHEQUE_GLOBAL, ID_CHEQUE_ITEM_GLOBAL, ID_SCALING_RATIO_CHI, ID_SCALING_RATIO_LOT,
	ID_GOODS_SR_CHI, ID_GOODS_SR_LOT, 
	SR_CHI_DENOMINATOR, SR_CHI_NUMERATOR,
	SR_LOT_DENOMINATOR, SR_LOT_NUMERATOR,
	SR_NOT_EQUAL)
SELECT CHI.ID_CHEQUE_GLOBAL, CHI.ID_CHEQUE_ITEM_GLOBAL, CHI.ID_SCALING_RATIO, L.ID_SCALING_RATIO,
	SR_CHI.ID_GOODS, SR_LOT.ID_GOODS,
	SR_CHI.DENOMINATOR, SR_CHI.NUMERATOR,
	SR_LOT.DENOMINATOR, SR_LOT.NUMERATOR,
    CASE WHEN SR_CHI.DENOMINATOR <> SR_LOT.DENOMINATOR OR SR_CHI.NUMERATOR <> SR_LOT.NUMERATOR THEN 1
        ELSE 0
    END
FROM CHEQUE_ITEM CHI
	INNER JOIN SCALING_RATIO SR_CHI ON CHI.ID_SCALING_RATIO = SR_CHI.ID_SCALING_RATIO
    INNER JOIN LOT L ON CHI.ID_LOT_GLOBAL = L.ID_LOT_GLOBAL
    INNER JOIN SCALING_RATIO SR_LOT ON L.ID_SCALING_RATIO = SR_LOT.ID_SCALING_RATIO
WHERE CHI.ID_SCALING_RATIO <> L.ID_SCALING_RATIO

IF EXISTS(SELECT * FROM #T_SR) BEGIN
	IF ISNULL(@OPTION, '') <> 'REPAIR' BEGIN
		SELECT 'Проблемные строки чеков'
		SELECT 'Код чека', 'Дата чека', 'Сумма чека', 'Мнемокод чека', 'Товар КД в строке чека', 'Товар КД в партии строки чека'
		SELECT CH.ID_CHEQUE, CH.DATE_CHEQUE, CH.SUMM, CH.MNEMOCODE, G_CH.NAME AS G_CH_NAME, G_LOT.NAME AS G_LOT_NAME
		FROM CHEQUE CH
			INNER JOIN #T_SR T ON T.ID_CHEQUE_GLOBAL = CH.ID_CHEQUE_GLOBAL
			LEFT JOIN GOODS G_CH ON T.ID_GOODS_SR_CHI = G_CH.ID_GOODS
			LEFT JOIN GOODS G_LOT ON T.ID_GOODS_SR_LOT = G_LOT.ID_GOODS
		ORDER BY CH.DATE_CHEQUE, CH.MNEMOCODE

		-- из них с несовпадающими числителем или знаменателем
		SELECT 'Из них с несовпадающими числителем или знаменателем'
		SELECT 'Код чека', 'Дата чека', 'Сумма чека', 'Мнемокод чека', 'Товар КД в строке чека', 'Товар КД в партии строки чека',
			'КД в строке чека', 'КД в партии строки чека'
		SELECT 
				CH.ID_CHEQUE,
				CH.DATE_CHEQUE,
				CH.SUMM,
				CH.MNEMOCODE,
				G_CH.NAME AS G_CH_NAME,
				G_LOT.NAME AS G_LOT_NAME,
				CAST(T.SR_CHI_NUMERATOR AS VARCHAR(8)) + '/' + CAST(T.SR_CHI_DENOMINATOR AS VARCHAR(8)) AS SR_CHI, 
				CAST(T.SR_LOT_NUMERATOR AS VARCHAR(8)) + '/' + CAST(T.SR_LOT_DENOMINATOR AS VARCHAR(8)) AS SR_LOT
		FROM CHEQUE CH
			INNER JOIN #T_SR T ON T.ID_CHEQUE_GLOBAL = CH.ID_CHEQUE_GLOBAL
			LEFT JOIN GOODS G_CH ON T.ID_GOODS_SR_CHI = G_CH.ID_GOODS
			LEFT JOIN GOODS G_LOT ON T.ID_GOODS_SR_LOT = G_LOT.ID_GOODS
		WHERE T.SR_NOT_EQUAL = 1
		ORDER BY CH.DATE_CHEQUE, CH.MNEMOCODE
	END
	ELSE BEGIN
		-- исправление
		UPDATE CHI SET CHI.ID_SCALING_RATIO = L.ID_SCALING_RATIO
		FROM CHEQUE_ITEM CHI
			INNER JOIN SCALING_RATIO SR_CHI ON CHI.ID_SCALING_RATIO = SR_CHI.ID_SCALING_RATIO
			INNER JOIN LOT L ON CHI.ID_LOT_GLOBAL = L.ID_LOT_GLOBAL
		WHERE CHI.ID_SCALING_RATIO <> L.ID_SCALING_RATIO
		SELECT @ROWCOUNT = @@ROWCOUNT
		SELECT 'Исправлены коэф.деления (КД в строке чека исправлен на КД из партии) в строках чеков: ' + CAST(@ROWCOUNT AS VARCHAR(20))
	END
END
ELSE BEGIN
	SELECT 'Нет чеков с такой ошибкой'
END
 
RETURN 0
GO
/*
EXEC UTL_CHECK_CHEQUE_SR_GOODS
*/

/****** Object:  StoredProcedure [dbo].[UTL_CHECK_LOST_CHEQUE]    Script Date: 08/25/2011 11:57:10 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF OBJECT_ID(N'DBO.UTL_CHECK_LOST_CHEQUE') IS NULL EXEC(N'CREATE PROCEDURE DBO.UTL_CHECK_LOST_CHEQUE AS RETURN')
GO
ALTER PROCEDURE [dbo].[UTL_CHECK_LOST_CHEQUE] 
	@OPTION VARCHAR(8) = NULL 
AS
-- Проверка на чеки без кассовых смен
DECLARE @ROWCOUNT INT
CREATE TABLE #CHEQUE (
    ID_CHEQUE_GLOBAL UNIQUEIDENTIFIER PRIMARY KEY,
    ID_CHEQUE BIGINT,
    DATE_CHEQUE	DATETIME,
    DOCUMENT_STATE VARCHAR(20) ,
    CHEQUE_TYPE	VARCHAR(20),
    SUMM MONEY,
    SUM_DISCOUNT MONEY,
    ID_CASH_SESSION_GLOBAL UNIQUEIDENTIFIER)

CREATE TABLE #LOT_MOVEMENT (
    ID_CHEQUE_GLOBAL UNIQUEIDENTIFIER,
    ID_LOT_MOVEMENT BIGINT,
    DATE_OP DATETIME,
    SUM_ACC MONEY,
    DISCOUNT_ACC MONEY)

CREATE TABLE #CHEQUE_INFO (
    ID_CHEQUE_GLOBAL UNIQUEIDENTIFIER PRIMARY KEY,
    DATE_OP DATETIME,
    SUM_ACC MONEY,
    DISCOUNT_ACC MONEY)

-- чеки без кассовых смен
INSERT #CHEQUE (
    ID_CHEQUE,
    ID_CHEQUE_GLOBAL,
    DATE_CHEQUE,
    DOCUMENT_STATE,
    CHEQUE_TYPE,
    SUMM,
    SUM_DISCOUNT)
SELECT 
    ID_CHEQUE,
    ID_CHEQUE_GLOBAL,
    DATE_CHEQUE,
    DOCUMENT_STATE,
    CHEQUE_TYPE,
    SUMM,
    SUM_DISCOUNT
FROM CHEQUE
WHERE ID_CASH_SESSION_GLOBAL NOT IN (SELECT ID_CASH_SESSION_GLOBAL FROM CASH_SESSION)

SET @ROWCOUNT = @@ROWCOUNT

IF @ROWCOUNT > 0 BEGIN
    INSERT #LOT_MOVEMENT (
        ID_CHEQUE_GLOBAL,
        ID_LOT_MOVEMENT,
        DATE_OP,
        SUM_ACC,
        DISCOUNT_ACC)
    SELECT
        CI.ID_CHEQUE_GLOBAL,
        LM.ID_LOT_MOVEMENT,
        LM.DATE_OP,
        LM.SUM_ACC,
        LM.DISCOUNT_ACC
    FROM CHEQUE_ITEM CI 
        LEFT JOIN LOT_MOVEMENT LM ON CI.ID_CHEQUE_ITEM_GLOBAL = LM.ID_DOCUMENT_ITEM
    WHERE CI.ID_CHEQUE_GLOBAL IN (SELECT ID_CHEQUE_GLOBAL FROM #CHEQUE)

    INSERT #CHEQUE_INFO (
        ID_CHEQUE_GLOBAL,
        DATE_OP,
        SUM_ACC,
        DISCOUNT_ACC)
    SELECT
        ID_CHEQUE_GLOBAL,
        MAX(DATE_OP),
        SUM(SUM_ACC),
        SUM(DISCOUNT_ACC)
    FROM #LOT_MOVEMENT
    GROUP BY ID_CHEQUE_GLOBAL
END

IF @ROWCOUNT > 0
BEGIN
    IF (@OPTION = 'REPAIR') BEGIN
        SELECT '-----------------------------------------------------------------------------'
        SELECT 'Проверка на чеки без кассовых смен:'
        -- поставить на чеках кассовую смену по дате чека
        UPDATE #CHEQUE 
        SET ID_CASH_SESSION_GLOBAL = (
                  SELECT TOP 1 ID_CASH_SESSION_GLOBAL 
                  FROM CASH_SESSION
                  WHERE DATE_CHEQUE BETWEEN 
                        CAST(CONVERT(VARCHAR(10), DATE_OPEN, 112) AS DATETIME)
                    AND CAST(CONVERT(VARCHAR(10), DATE_CLOSE, 112) AS DATETIME) + 1)

        DECLARE @ID_CASH_SESSION_GLOBAL UNIQUEIDENTIFIER
        DECLARE CUR CURSOR LOCAL READ_ONLY FAST_FORWARD
        FOR
            SELECT DISTINCT ID_CASH_SESSION_GLOBAL
            FROM #CHEQUE
        OPEN CUR
        WHILE 1 = 1 
        BEGIN
            FETCH NEXT FROM CUR INTO @ID_CASH_SESSION_GLOBAL
            IF @@FETCH_STATUS <> 0 BREAK
            BEGIN TRAN
                -- поставить кассовую смену на проводки чеков
                UPDATE LM
                SET LM.ID_DOCUMENT = @ID_CASH_SESSION_GLOBAL
                FROM LOT_MOVEMENT LM
                    INNER JOIN #LOT_MOVEMENT T ON LM.ID_LOT_MOVEMENT = T.ID_LOT_MOVEMENT
                    INNER JOIN #CHEQUE C ON C.ID_CHEQUE_GLOBAL = T.ID_CHEQUE_GLOBAL
                WHERE T.ID_LOT_MOVEMENT IS NOT NULL
                    AND C.ID_CASH_SESSION_GLOBAL = @ID_CASH_SESSION_GLOBAL
                IF @@ERROR <> 0 GOTO ERR
                -- поставить кассовую смену на чеки
                UPDATE C
                SET C.ID_CASH_SESSION_GLOBAL = @ID_CASH_SESSION_GLOBAL
                FROM CHEQUE C
                    INNER JOIN #CHEQUE C_T ON C.ID_CHEQUE_GLOBAL = C_T.ID_CHEQUE_GLOBAL
                WHERE C_T.ID_CASH_SESSION_GLOBAL = @ID_CASH_SESSION_GLOBAL
                IF @@ERROR <> 0 GOTO ERR
                -- обновить кассовую смену
                EXEC USP_CASH_SESSION_UPDATE @ID_CASH_SESSION_GLOBAL
                IF @@ERROR <> 0 GOTO ERR
                GOTO SUC
                ERR:
                    IF @@TRANCOUNT > 0 ROLLBACK
                    SELECT 'ошибка при исправлении чеков'
                    SET @ROWCOUNT = @ROWCOUNT + 1
                SUC:
            IF @@TRANCOUNT > 0 COMMIT
        END
        CLOSE CUR
        DEALLOCATE CUR

        SELECT 'исправлено чеков без кассовых смен: ' + CAST(@ROWCOUNT AS VARCHAR(10)) 
    END
    ELSE BEGIN
        SELECT '-----------------------------------------------------------------------------'
        SELECT 'Проверка на чеки без кассовых смен:'
        SELECT 'обнаружены чеки без кассовых смен:'
        SELECT 'Код чека', 'Дата чека', 'Состояние чека', 'Тип чека', 'Сумма розн', 'Сумма скидки', 'Дата проводки', 'Сумма пров.розн.', 'Сумма пров.скидки'
        SELECT 
            C.ID_CHEQUE,
            C.DATE_CHEQUE,
            C.DOCUMENT_STATE ,
            C.CHEQUE_TYPE,
            C.SUMM,
            C.SUM_DISCOUNT,
            LM.DATE_OP,
            LM.SUM_ACC,
            LM.DISCOUNT_ACC
        FROM #CHEQUE C
            LEFT JOIN #LOT_MOVEMENT LM ON C.ID_CHEQUE_GLOBAL = LM.ID_CHEQUE_GLOBAL
        ORDER BY C.DATE_CHEQUE, LM.DATE_OP, C.ID_CHEQUE
    END
END
ELSE
BEGIN
    SELECT '-----------------------------------------------------------------------------'
    SELECT 'Проверка на чеки без кассовых смен:'
    SELECT 'нет чеков без кассовых смен'
END
RETURN
GO
/*
exec [UTL_CHECK_LOST_CHEQUE]
*/


/****** Object:  StoredProcedure [dbo].[UTL_CHECK_LOT]    Script Date: 08/25/2011 12:49:30 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO
IF OBJECT_ID(N'DBO.UTL_CHECK_LOT') IS NULL EXEC(N'CREATE PROCEDURE DBO.UTL_CHECK_LOT AS RETURN')
GO
ALTER PROCEDURE [dbo].[UTL_CHECK_LOT]
	(@OPTION VARCHAR(8) = NULL,
	 @MESSAGE VARCHAR(256),
	 @ID_TABLE INT,
	 @DOC_TABLE VARCHAR(128),
 	 @OUT_FIELDS_HEADER VARCHAR(300),
	 @OUT_FIELDS VARCHAR(300),
	 @DOC_FILTER VARCHAR(300)) 
AS
-- вспомогательная проца

DECLARE @SQL_TEXT NVARCHAR(4000)
SET @MESSAGE = ISNULL(@MESSAGE, '')
-- проверка на существование документа, породившего партию
-- проверка на существование партии, порожденной документом
SET @SQL_TEXT = '
	SELECT  
      distinct  LOT.LOT_NAME    
	INTO #ERR1 FROM LOT WITH(NOLOCK)
	    LEFT JOIN {DOC_TABLE} DOC WITH(NOLOCK) ON DOC.ID_{DOC_TABLE}_GLOBAL = LOT.ID_DOCUMENT
	WHERE LOT.ID_TABLE = @ID_TABLE AND DOC.ID_{DOC_TABLE}_GLOBAL IS NULL

	IF @@ROWCOUNT <> 0 BEGIN
        SELECT ''-----------------------------------------------------------------------------''
		SELECT ''Проверка на существование документа, породившего партию '' + @MESSAGE
        SELECT ''Для этих партий не найден документ, ее породивший:''
	    SELECT ''{OUT_FIELDS_HEADER}''
        SELECT * FROM #ERR1 ORDER BY LOT_NAME
	END
    ELSE BEGIN
        SELECT ''-----------------------------------------------------------------------------''
		SELECT ''Проверка на существование документа, породившего партию '' + @MESSAGE
        SELECT ''Для этих партий не найден документ, ее породивший:''
        SELECT ''Нет таких партий''
    END

	SELECT {OUT_FIELDS}
	INTO #ERR2 FROM {DOC_TABLE} DOC WITH(NOLOCK)
	    LEFT JOIN LOT WITH(NOLOCK) ON LOT.ID_DOCUMENT = DOC.ID_{DOC_TABLE}_GLOBAL AND LOT.ID_TABLE = @ID_TABLE
	WHERE {DOC_FILTER} AND LOT.ID_DOCUMENT IS NULL

	IF @@ROWCOUNT <> 0 BEGIN
        SELECT ''-----------------------------------------------------------------------------''
		SELECT ''Проверка на существование партии, порожденной документом '' + @MESSAGE
        SELECT ''Для этих документов не найдены партии, порожденные ими:''
        SELECT ''{OUT_FIELDS_HEADER}''
        SELECT * FROM #ERR2 DOC ORDER BY {OUT_FIELDS}
	END
    ELSE BEGIN
        SELECT ''-----------------------------------------------------------------------------''
		SELECT ''Проверка на существование партии, порожденной документом '' + @MESSAGE
        SELECT ''Для этих документов не найдены партии, порожденные ими:''
        SELECT ''Нет таких документов''   
    END
'
SET @SQL_TEXT = REPLACE(@SQL_TEXT, '{OUT_FIELDS_HEADER}', @OUT_FIELDS_HEADER)
SET @SQL_TEXT = REPLACE(@SQL_TEXT, '{OUT_FIELDS}', @OUT_FIELDS)
SET @SQL_TEXT = REPLACE(@SQL_TEXT, '{DOC_TABLE}', @DOC_TABLE)
SET @SQL_TEXT = REPLACE(@SQL_TEXT, '{DOC_FILTER}', @DOC_FILTER)

-- PRINT @SQL_TEXT
EXEC SP_EXECUTESQL @SQL_TEXT, N'@ID_TABLE INT, @OPTION VARCHAR(8), @MESSAGE VARCHAR(256)',
	@ID_TABLE = @ID_TABLE, @OPTION = @OPTION, @MESSAGE = @MESSAGE

RETURN
GO



/****** Object:  StoredProcedure [dbo].[UTL_CHECK_LOT_DOCUMENT]    Script Date: 08/25/2011 12:44:54 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF OBJECT_ID(N'DBO.UTL_CHECK_LOT_DOCUMENT') IS NULL EXEC(N'CREATE PROCEDURE DBO.UTL_CHECK_LOT_DOCUMENT AS RETURN')
GO
ALTER PROCEDURE [dbo].[UTL_CHECK_LOT_DOCUMENT] 
    @OPTION VARCHAR(8) = NULL
AS
-- проверка на существование документа, породившего партию
-- проверка на существование партии, порожденной документом
EXEC UTL_CHECK_LOT @OPTION, '(по приходным накладным)',
    2, 'INVOICE', 'Мнемокод документа, Дата документа', 
    'DOC.MNEMOCODE, DOC.DOCUMENT_DATE', "DOCUMENT_STATE IN('PROC', 'RES')"

EXEC UTL_CHECK_LOT @OPTION, '(по актам разукомплектации',
    6, 'ACT_DISASSEMBLING', 'Мнемокод документа, Дата документа', 
    'DOC.MNEMOCODE, DOC.DATE', "DOCUMENT_STATE IN('PROC', 'RES')"

EXEC UTL_CHECK_LOT @OPTION, '(по актам переоценки)',
    13, 'ACT_REVALUATION2', 'Мнемокод документа, Дата документа', 
    'DOC.MNEMOCODE, DOC.DATE', "DOCUMENT_STATE IN('PROC', 'RES')"

RETURN
GO
/*
EXEC UTL_CHECK_LOT_DOCUMENT
*/


/****** Object:  StoredProcedure [dbo].[UTL_CHECK_LOT_MOVEMENT_WOUT_REF_ON_LOT]    Script Date: 08/25/2011 13:12:19 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF OBJECT_ID(N'DBO.UTL_CHECK_LOT_MOVEMENT_WOUT_REF_ON_LOT') IS NULL EXEC(N'CREATE PROCEDURE DBO.UTL_CHECK_LOT_MOVEMENT_WOUT_REF_ON_LOT AS RETURN')
GO
ALTER PROCEDURE [dbo].[UTL_CHECK_LOT_MOVEMENT_WOUT_REF_ON_LOT]
    @OPTION VARCHAR(8) = NULL
AS
DECLARE @ROWCOUNT INT
SET NOCOUNT ON 

-- проблемные проводки
SELECT
    LM.ID_LOT_MOVEMENT
INTO #LM
FROM LOT_MOVEMENT LM LEFT JOIN LOT L ON LM.ID_LOT_GLOBAL = L.ID_LOT_GLOBAL
WHERE L.ID_LOT_GLOBAL IS NULL

SET @ROWCOUNT = @@ROWCOUNT

SELECT '-----------------------------------------------------------'
SELECT 'Проверка соответствия партии в проводках и в справочнике партий:'

IF @ROWCOUNT = 0 BEGIN
    SELECT 'Расхождений нет'
    RETURN         -- выход  из процы
END

SELECT 'Проблемные проводки'
SELECT 'Тип документа', 'Дата проводки', 'Кол-во ADD', 'Кол-во SUB', 'Кол-во RES', 'Сумма поставщика', 'Сумма розница', 'Код партии'
SELECT 
    TD.DESCRIPTION,
    LM.DATE_OP,
    LM.QUANTITY_ADD,
    LM.QUANTITY_SUB,
    LM.QUANTITY_RES,
    LM.SUM_SUP,
    LM.SUM_ACC,
    LM.ID_LOT_GLOBAL
FROM #LM T
    INNER JOIN LOT_MOVEMENT LM ON T.ID_LOT_MOVEMENT = LM.ID_LOT_MOVEMENT
    INNER JOIN TABLE_DATA TD ON LM.ID_TABLE = TD.ID_TABLE_DATA
    LEFT JOIN ALL_DOCUMENT ALD ON LM.ID_DOCUMENT = ALD.ID_DOCUMENT_GLOBAL
ORDER BY LM.DATE_OP

RETURN
GO
/*
EXEC UTL_CHECK_LOT_MOVEMENT_WOUT_REF_ON_LOT
*/

/****** Object:  StoredProcedure [dbo].[UTL_CHECK_LOT_QTY_BY_LOT_MOVEMENT]    Script Date: 08/25/2011 12:29:01 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO
IF OBJECT_ID(N'DBO.UTL_CHECK_LOT_QTY_BY_LOT_MOVEMENT') IS NULL EXEC(N'CREATE PROCEDURE DBO.UTL_CHECK_LOT_QTY_BY_LOT_MOVEMENT AS RETURN')
GO
ALTER PROCEDURE [dbo].[UTL_CHECK_LOT_QTY_BY_LOT_MOVEMENT]
	@OPTION VARCHAR(8) = NULL
AS
-- Проверка итогов партий по движениям партий
DECLARE @ROWCOUNT INT

DECLARE @MOVEMENT TABLE (
    ID_LOT_GLOBAL UNIQUEIDENTIFIER PRIMARY KEY, 
    QUANTITY_ADD_LM MONEY,
    QUANTITY_SUB_LM MONEY,
    QUANTITY_RES_LM MONEY)

DECLARE @LOT_ERR TABLE (
    ID_LOT_GLOBAL UNIQUEIDENTIFIER PRIMARY KEY, 
    QUANTITY_ADD_LM MONEY,
    QUANTITY_SUB_LM MONEY,
    QUANTITY_RES_LM MONEY,
    QUANTITY_ADD MONEY,
    QUANTITY_SUB MONEY,
    QUANTITY_RES MONEY)

INSERT @MOVEMENT (
    ID_LOT_GLOBAL,
    QUANTITY_ADD_LM,
    QUANTITY_SUB_LM,
    QUANTITY_RES_LM)
SELECT 
    ID_LOT_GLOBAL, 
	QUANTITY_ADD_LM = SUM(QUANTITY_ADD), 
	QUANTITY_SUB_LM = SUM(QUANTITY_SUB),
	QUANTITY_RES_LM = SUM(QUANTITY_RES)
FROM LOT_MOVEMENT 
GROUP BY ID_LOT_GLOBAL

INSERT @LOT_ERR(
    ID_LOT_GLOBAL, 
    QUANTITY_ADD,
    QUANTITY_SUB,
    QUANTITY_RES,
    QUANTITY_ADD_LM,
    QUANTITY_SUB_LM,
    QUANTITY_RES_LM)
SELECT 
    LOT.ID_LOT_GLOBAL, 
	LOT.QUANTITY_ADD, 
	LOT.QUANTITY_SUB, 
	LOT.QUANTITY_RES,
    MOV.QUANTITY_ADD_LM,
    MOV.QUANTITY_SUB_LM,
    MOV.QUANTITY_RES_LM
FROM LOT 
    INNER JOIN @MOVEMENT MOV ON LOT.ID_LOT_GLOBAL = MOV.ID_LOT_GLOBAL 
WHERE
	   LOT.QUANTITY_ADD <> MOV.QUANTITY_ADD_LM
	OR LOT.QUANTITY_SUB <> MOV.QUANTITY_SUB_LM 
	OR LOT.QUANTITY_RES <> MOV.QUANTITY_RES_LM

SELECT @ROWCOUNT = COUNT(*) FROM @LOT_ERR

IF @ROWCOUNT <> 0 BEGIN
	IF @OPTION = 'REPAIR' BEGIN
		UPDATE LOT SET
			LOT.QUANTITY_ADD = LE.QUANTITY_ADD_LM,
			LOT.QUANTITY_SUB = LE.QUANTITY_SUB_LM, 
			LOT.QUANTITY_RES = LE.QUANTITY_RES_LM
		FROM @LOT_ERR LE 
            INNER JOIN LOT ON LE.ID_LOT_GLOBAL = LOT.ID_LOT_GLOBAL

        SELECT '-----------------------------------------------------------------------------'
        SELECT 'Проверка итогов партий по движениям партий:'
        SELECT 'Исправлены итоги для ' + CAST(@ROWCOUNT AS VARCHAR(10)) + ' партий'
	END
    ELSE BEGIN
        SELECT '-----------------------------------------------------------------------------'
        SELECT 'Проверка итогов партий по движениям партий:'
        SELECT 'Склад партии', 'Товар', 'Мнемокод партии', 'Приход в партии', 'Приход по движению', 'Расход в партии', 'Расход по движению', 'Резерв в партии', 'Резерв по движению'
    	SELECT 
            S.NAME AS S_NAME,
            G.NAME AS G_NAME,
            L.LOT_NAME,
            LE.QUANTITY_ADD,
            LE.QUANTITY_ADD_LM,
            LE.QUANTITY_SUB,
            LE.QUANTITY_SUB_LM,
            LE.QUANTITY_RES,
            LE.QUANTITY_RES_LM
        FROM @LOT_ERR LE
            INNER JOIN LOT L ON LE.ID_LOT_GLOBAL = L.ID_LOT_GLOBAL
            LEFT JOIN GOODS G ON L.ID_GOODS = G.ID_GOODS
            LEFT JOIN STORE S ON S.ID_STORE = L.ID_STORE
        ORDER BY S.NAME, G.NAME, L.LOT_NAME
    END
END
ELSE BEGIN
    SELECT '-----------------------------------------------------------------------------'
    SELECT 'Проверка итогов партий по движениям партий:'
    SELECT 'Расхождений не обнаружено'
END
RETURN
GO
/*
exec UTL_CHECK_LOT_QTY_BY_LOT_MOVEMENT
*/


/****** Object:  StoredProcedure [dbo].[UTL_CHECK_PROC_CHEQUE_WOUT_LOT_MOVEMENT]    Script Date: 08/25/2011 12:59:42 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF OBJECT_ID(N'DBO.UTL_CHECK_PROC_CHEQUE_WOUT_LOT_MOVEMENT') IS NULL EXEC(N'CREATE PROCEDURE DBO.UTL_CHECK_PROC_CHEQUE_WOUT_LOT_MOVEMENT AS RETURN')
GO
ALTER PROCEDURE [dbo].[UTL_CHECK_PROC_CHEQUE_WOUT_LOT_MOVEMENT]
	@OPTION VARCHAR(8) = NULL
AS
-- восстановление проводок чеков 
DECLARE @ROWCOUNT INT

SELECT DISTINCT
	D.ID_CHEQUE_GLOBAL
INTO #DOC
FROM CHEQUE D
    INNER JOIN CHEQUE_ITEM DI ON D.ID_CHEQUE_GLOBAL = DI.ID_CHEQUE_GLOBAL
WHERE NOT EXISTS (SELECT 1 FROM LOT_MOVEMENT LM 
                  WHERE DI.ID_CHEQUE_ITEM_GLOBAL = LM.ID_DOCUMENT_ITEM)
      AND NOT EXISTS (SELECT 1 FROM SERVICE_4_SALE_MOVEMENT SSM 
                  WHERE DI.ID_CHEQUE_ITEM_GLOBAL = SSM.ID_DOCUMENT_ITEM)
    AND D.DOCUMENT_STATE = 'PROC'

SET @ROWCOUNT = @@ROWCOUNT

IF @ROWCOUNT = 0 BEGIN
    SELECT '-----------------------------------------------------------------------------'
	SELECT 'Проверка на отсутствие проводок у проведенных чеков:'
    SELECT 'Нет таких чеков.'    
    RETURN    -- выход
END

IF ISNULL(@OPTION, '') <> 'REPAIR' BEGIN
    SELECT '-----------------------------------------------------------------------------'
    SELECT 'Проверка на отсутствие проводок у проведенных чеков:'
    SELECT 'Эти чеки не имеют проводок:'
    SELECT 'Дата открытия сессии', 'Номер сессии', 'Дата чека', 'Код чека'
    SELECT CS.DATE_OPEN, CS.MNEMOCODE, CH.DATE_CHEQUE, CH.ID_CHEQUE
    FROM #DOC D
        INNER JOIN CHEQUE CH ON D.ID_CHEQUE_GLOBAL = CH.ID_CHEQUE_GLOBAL
        INNER JOIN CASH_SESSION CS ON CH.ID_CASH_SESSION_GLOBAL = CS.ID_CASH_SESSION_GLOBAL
    ORDER BY CS.DATE_OPEN, CS.MNEMOCODE, CH.DATE_CHEQUE, CH.ID_CHEQUE

    RETURN    -- выход
END

-- исправление 
INSERT INTO LOT_MOVEMENT (
	ID_LOT_GLOBAL, DATE_OP, CODE_OP,
	QUANTITY_ADD, 
    QUANTITY_SUB, 
    QUANTITY_RES, 
	ID_TABLE, ID_DOCUMENT, ID_DOCUMENT_ITEM,
	SVAT_SUP, 
    SUM_SUP, 
    SVAT_ACC, 
    SUM_ACC, 
    DISCOUNT_ACC)
SELECT  
	CI.ID_LOT_GLOBAL, CH.DATE_CHEQUE, 'CHEQUE', 
    0, 
    CASE CH.CHEQUE_TYPE WHEN 'RETURN' THEN -1 * CI.QUANTITY ELSE CI.QUANTITY END, 
    0,
	19, CH.ID_CASH_SESSION_GLOBAL, CI.ID_CHEQUE_ITEM_GLOBAL,
	ABS(CI.QUANTITY) * L.PVAT_SUP, 
    ABS(CI.QUANTITY) * L.PRICE_SUP, 
    CI.SUMM * CAST(L.VAT_SAL AS MONEY) / (100+CAST(L.VAT_SAL AS MONEY)), 
    CI.SUMM, 
    CI.SUMM_DISCOUNT
FROM CHEQUE CH 
    INNER JOIN CHEQUE_ITEM CI ON CH.ID_CHEQUE_GLOBAL = CI.ID_CHEQUE_GLOBAL
    INNER JOIN LOT L ON CI.ID_LOT_GLOBAL = L.ID_LOT_GLOBAL
WHERE CH.ID_CHEQUE_GLOBAL IN (SELECT ID_CHEQUE_GLOBAL FROM #DOC)

SELECT '-----------------------------------------------------------------------------'
SELECT 'Проверка на отсутствие проводок у проведенных чеков:'
SELECT 'Созданы проводки для чеков: ' + CAST(@ROWCOUNT AS VARCHAR(10))    

RETURN
GO 
/*

EXEC UTL_CHECK_PROC_CHEQUE_WOUT_LOT_MOVEMENT
*/


/****** Object:  StoredProcedure [dbo].[UTL_LOT_MOVEMENT_WITH_SERO_QTY]    Script Date: 08/25/2011 12:36:46 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF OBJECT_ID(N'DBO.UTL_LOT_MOVEMENT_WITH_SERO_QTY') IS NULL EXEC(N'CREATE PROCEDURE DBO.UTL_LOT_MOVEMENT_WITH_SERO_QTY AS RETURN')
GO
ALTER PROCEDURE [dbo].[UTL_LOT_MOVEMENT_WITH_SERO_QTY] 
    @OPTION VARCHAR(8) = NULL
AS
-- Проводки с нулевыми кол-вами движения

SELECT LM.ID_LOT_MOVEMENT    --, LOT.LOT_NAME
INTO #EMPTY_MOVE
FROM LOT_MOVEMENT LM WITH(NOLOCK)
--    LEFT JOIN LOT WITH(NOLOCK) ON LOT.ID_LOT_GLOBAL = LM.ID_LOT_GLOBAL
WHERE LM.QUANTITY_ADD = 0 AND LM.QUANTITY_SUB = 0 AND LM.QUANTITY_RES = 0

IF @@ROWCOUNT <> 0 BEGIN
    SELECT '-----------------------------------------------------------------------------'
    SELECT 'Проводки с нулевыми кол-вами движения'
	SELECT 'Имеются проводки с нулевыми кол-вами движения:'
    SELECT 'Дата док-та', 'Состояние док-та', 'Номер док-та', 'Дата проводки', 'Код операции', 'Код типа док-та'    
    SELECT 
        ALD.DOC_DATE,
        ALD.DOC_STATE,
        ALD.DOC_NUM,
        LM.DATE_OP,
        LM.CODE_OP,
        LM.ID_TABLE
    FROM LOT_MOVEMENT LM
        LEFT JOIN ALL_DOCUMENT ALD ON LM.ID_DOCUMENT = ALD.ID_DOCUMENT_GLOBAL
    WHERE LM.ID_LOT_MOVEMENT IN (SELECT ID_LOT_MOVEMENT FROM #EMPTY_MOVE)
    ORDER BY ALD.DOC_DATE, ALD.DOC_STATE, ALD.DOC_NUM
END
ELSE BEGIN
    SELECT '-----------------------------------------------------------------------------'
    SELECT 'Проводки с нулевыми кол-вами движения:'
	SELECT 'Не обнаружены'
END

RETURN
GO 
/*
exec UTL_LOT_MOVEMENT_WITH_SERO_QTY
*/



/****** Object:  StoredProcedure [dbo].[UTL_LOT_PRICE_SAL_LESS_PRICE_SUP]    Script Date: 08/25/2011 12:39:24 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF OBJECT_ID(N'DBO.UTL_LOT_PRICE_SAL_LESS_PRICE_SUP') IS NULL EXEC(N'CREATE PROCEDURE DBO.UTL_LOT_PRICE_SAL_LESS_PRICE_SUP AS RETURN')
GO
ALTER PROCEDURE [dbo].[UTL_LOT_PRICE_SAL_LESS_PRICE_SUP]
    @OPTION VARCHAR(8) = NULL
AS

-- Розничная цена партии меньше закупочной или 
-- цена поставищка меньше цены производителя или
-- цена поставищка меньши 0 или цена розничная меньше 0

SELECT G.NAME AS G_NAME, LOT.LOT_NAME, LOT.PRICE_PROD, LOT.PRICE_SUP, LOT.PRICE_SAL
INTO #LOT_ERRORS_PRICE 
FROM LOT 
INNER JOIN GOODS G ON G.ID_GOODS = LOT.ID_GOODS
WHERE LOT.QUANTITY_REM > 0 
     AND 
    (LOT.PRICE_SUP <= 0 OR 
     LOT.PRICE_SAL <= 0 OR 
     LOT.PRICE_PROD > 1.1 * LOT.PRICE_SUP OR 
     LOT.PRICE_SUP > 1.1 * LOT.PRICE_SAL)
IF @@ROWCOUNT <> 0 BEGIN
    SELECT '-----------------------------------------------------------------------------'
	SELECT 'Сравнительная проверка цен партий:'
    SELECT 'У этих партий неверные цены:'
    SELECT 'Товар', 'Мнемокод партии', 'Цена производителя', 'Цена поставщика', 'Цена розничная'
    SELECT G_NAME, LOT_NAME, PRICE_PROD, PRICE_SUP, PRICE_SAL
    FROM #LOT_ERRORS_PRICE
    ORDER BY G_NAME, LOT_NAME
END
ELSE BEGIN
    SELECT '-----------------------------------------------------------------------------'
	SELECT 'Сравнительная проверка цен партий:'
    SELECT 'Ошибок не обнаружено'
END

RETURN
GO
/*
EXEC UTL_LOT_PRICE_SAL_LESS_PRICE_SUP
*/



/****** Object:  StoredProcedure [dbo].[UTL_LOT_QUANTITY_REM_LESS_ZERO]    Script Date: 08/25/2011 12:34:06 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
IF OBJECT_ID(N'DBO.UTL_LOT_QUANTITY_REM_LESS_ZERO') IS NULL EXEC(N'CREATE PROCEDURE DBO.UTL_LOT_QUANTITY_REM_LESS_ZERO AS RETURN')
GO
ALTER PROCEDURE [dbo].[UTL_LOT_QUANTITY_REM_LESS_ZERO]
    @OPTION VARCHAR(8) = NULL
AS

-- Остаток партии меньше 0 или сумма операций партии не равно остатку партии

SELECT LOT.LOT_NAME, G.NAME AS GOODS_NAME, LOT.QUANTITY_REM, LOT.QUANTITY_ADD,
    LOT.QUANTITY_SUB, LOT.QUANTITY_RES
INTO #LOT_NEGATIVE
FROM LOT LOT WITH(NOLOCK)
LEFT JOIN GOODS G WITH(NOLOCK) ON G.ID_GOODS = LOT.ID_GOODS
WHERE  (LOT.QUANTITY_REM <> 0 AND LOT.QUANTITY_REM < 0.1)
	OR (LOT.QUANTITY_REM <> LOT.QUANTITY_ADD - LOT.QUANTITY_SUB - LOT.QUANTITY_RES)
ORDER BY LOT.LOT_NAME

IF @@ROWCOUNT <> 0 BEGIN
    SELECT '-----------------------------------------------------------------------------'
	SELECT 'Проверка итогов партий (остаток, приход, расход, резерв)'
    SELECT 'Товар', 'Мнемокод партии', 'Итог остатка', 'Итог прихода', 'Итог расхода', 'Итог резерва'
    SELECT
         GOODS_NAME, LOT_NAME, QUANTITY_REM, QUANTITY_ADD, QUANTITY_SUB, QUANTITY_RES
    FROM #LOT_NEGATIVE
    ORDER BY GOODS_NAME, LOT_NAME
END
ELSE BEGIN
    SELECT '-----------------------------------------------------------------------------'
	SELECT 'Проверка итогов партий (остаток, приход, расход, резерв)' 
    SELECT 'Ошибок не обнаружено'
END
RETURN
GO
/*
exec UTL_LOT_QUANTITY_REM_LESS_ZERO
*/


/****** Object:  StoredProcedure [dbo].[UTL_CHECK_DATABASE_LIST]    Script Date: 09/01/2011 12:55:57 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO
IF OBJECT_ID(N'DBO.UTL_CHECK_DATABASE_LIST') IS NULL EXEC(N'CREATE PROCEDURE DBO.UTL_CHECK_DATABASE_LIST AS RETURN')
GO
ALTER PROCEDURE [dbo].[UTL_CHECK_DATABASE_LIST]
AS

SELECT * FROM DBO.FN_CHECK_DATABASE_LIST()
ORDER BY SORT_ORDER

RETURN
GO
/*
exec UTL_CHECK_DATABASE_LIST
*/


/****** Object:  UserDefinedFunction [dbo].[FN_CHECK_DATABASE_LIST]    Script Date: 09/01/2011 12:57:10 ******/

SET ANSI_NULLS OFF
GO
SET QUOTED_IDENTIFIER ON
GO

IF OBJECT_ID('DBO.FN_CHECK_DATABASE_LIST') IS NULL 
EXEC ('CREATE FUNCTION DBO.FN_CHECK_DATABASE_LIST() 
		RETURNS @T TABLE(
						CODE VARCHAR(100),
						NAME VARCHAR(256),
						DESCRIPTION VARCHAR(2000), 
						IS_CORRECTABLE BIT, 
						SORT_ORDER INT, 
						PROC_NAME VARCHAR(100)
						) 
     AS BEGIN return END')
GO

--drop  FUNCTION [dbo].[FN_CHECK_DATABASE_LIST]
ALTER FUNCTION [dbo].[FN_CHECK_DATABASE_LIST] () 
RETURNS @T TABLE 
	(CODE VARCHAR(100),
     NAME VARCHAR(256),
     DESCRIPTION VARCHAR(2000), 
     IS_CORRECTABLE BIT, 
     SORT_ORDER INT, 
     PROC_NAME VARCHAR(100))
AS
BEGIN
        INSERT @T (CODE, NAME, 
                   DESCRIPTION, 
                   IS_CORRECTABLE, SORT_ORDER, PROC_NAME)
    	SELECT 'STARTUP_CHECK', 'Проверки при старте программы', 
               'Проверяются некоторые настройки программы, например: 
наличие текущего контрагента, 
наличие склада у текущего контрагента и т.п.
Исправление не реализовано', 
               0, 1, 'UTL_STARTUP_CHECK'
        ---------------------
        INSERT @T (CODE, NAME, 
                   DESCRIPTION, 
                   IS_CORRECTABLE, SORT_ORDER, PROC_NAME)
    	SELECT 'REFRESH_ALL_DOCUMENT', 'Пересчет данных в общей таблице документов (ALL_DOCUMENT)', 
               'Пересчет данных в общей таблице документов (ALL_DOCUMENT)', 
               1, 2, 'UTL_REFRESH_ALL_DOCUMENT'
        ---------------------
        INSERT @T (CODE, NAME, 
                   DESCRIPTION, 
                   IS_CORRECTABLE, SORT_ORDER, PROC_NAME)
    	SELECT 'REFRESH_DOC_MOVEMENT', 'Пересчет данных в таблице для отчетов (DOC_MOVEMENT)', 
               'Пересчет данных в таблице для отчетов (DOC_MOVEMENT)', 
               1, 3, 'UTL_REFRESH_DOC_MOVEMENT'
        ---------------------
        INSERT @T (CODE, NAME, 
                   DESCRIPTION, 
                   IS_CORRECTABLE, SORT_ORDER, PROC_NAME)
    	SELECT 'CHECK_CASH_SESSION_SUM', 'Проверка сумм кассовых смен в таблице для отчетов', 
               'Проверка совпадения сумм в кассовых сменах и в таблице для отчетов (DOC_MOVEMENT)', 
               1, 4, 'UTL_CHECK_CASH_SESSION_SUM'
        ---------------------
        INSERT @T (CODE, NAME, 
                   DESCRIPTION, 
                   IS_CORRECTABLE, SORT_ORDER, PROC_NAME)
    	SELECT 'CHECK_LOST_CHEQUE', 'Проверка на чеки без кассовых смен', 
               'Поиск чеков, не принадлежащих кассовой смене',
               1, 5, 'UTL_CHECK_LOST_CHEQUE'
        ---------------------
        INSERT @T (CODE, NAME, 
                   DESCRIPTION, 
                   IS_CORRECTABLE, SORT_ORDER, PROC_NAME)
    	SELECT 'CHECK_CHEQUE', 'Проверки кассовых чеков и смен', 
               'Несколько проверок чек и кассовых смен:
Неправильные суммы или округление не до 2 знаков суммы по позициям чеков.
Исправление есть.
Итог по чеку не равен сумме позиций.
Исправление есть.
Итог по сессии не равен сумме чеков.
Исправление есть.
Товар не совпадает в проводках чека и в строках чека.
Исправления нет.
Коэффициент деления не совпадает в партии строки чека и в строке чека.
Исправления нет.
Цена продажи не совпадает в партии чека и в строках чека.
Исправления нет.
Дата закрытия сессии старше последнего чека.
Исправление есть.
Проводки по кассовым сменам принадлежат другой смене.
Исправления нет.', 
               1, 6, 'UTL_CHECK_CHEQUE'
        ---------------------
        INSERT @T (CODE, NAME, 
                   DESCRIPTION, 
                   IS_CORRECTABLE, SORT_ORDER, PROC_NAME)
    	SELECT 'CHECK_CHEQUE_LOT_MOVEMENT', 'Суммы в строке чека не равны суммам в проводке строки', 
               'Суммы в строке проведенного чека не равны суммам в проводке строки
или нет проводок у проведенного чека', 
               1, 7, 'UTL_CHECK_CHEQUE_LOT_MOVEMENT'
        ---------------------
        INSERT @T (CODE, NAME, 
                   DESCRIPTION, 
                   IS_CORRECTABLE, SORT_ORDER, PROC_NAME)
    	SELECT 'CHECK_CHEQUE_LOT', 'Проверка соответствия партии в строках чека и в справочнике партий', 
               'Поиск (и замена) в строках чеков партий, отсутствующих в справочнике партий
Партия для замены подбирается с таким же товаром, ценой и коэфициентом деления', 
               1, 8, 'UTL_CHECK_CHEQUE_LOT'
        ---------------------
        INSERT @T (CODE, NAME, 
                   DESCRIPTION, 
                   IS_CORRECTABLE, SORT_ORDER, PROC_NAME)
    	SELECT 'STOCK_RECORD_CHECK_QUANTITY', 'Проверка остатков на складах по движению партий', 
               'Проверяются остатки на складах (таблица STOCK_RECORD)
по движению партий (по проводкам документов)', 
               1, 9, 'USP_STOCK_RECORD_CHECK_QUANTITY'
        ---------------------
        INSERT @T (CODE, NAME, 
                   DESCRIPTION, 
                   IS_CORRECTABLE, SORT_ORDER, PROC_NAME)
    	SELECT 'CHECK_SUSPECT_LOT_MOVEMENT', 'Проверка на "подозрительные" проводки', 
               'Поиск проводок, не соответствующих по количеству строк строкам документов (кроме чеков).
Исправление не реализовано', 
               0, 10, 'UTL_CHECK_SUSPECT_LOT_MOVEMENT'
        ---------------------
        INSERT @T (CODE, NAME, 
                   DESCRIPTION, 
                   IS_CORRECTABLE, SORT_ORDER, PROC_NAME)
    	SELECT 'STOCK_RECORD_CHECK_LOT', 'Проверка соответствия партий и остатков на складах', 
               'Поиск остатков на складах (таблица STOCK_RECORD), по которым нет соответствующей партии.
Партии должны соответствовать остаткам по складу, товару и поставщику.
Исправление не реализовано', 
               0, 11, 'USP_STOCK_RECORD_CHECK_LOT'
        ---------------------
        INSERT @T (CODE, NAME, 
                   DESCRIPTION, 
                   IS_CORRECTABLE, SORT_ORDER, PROC_NAME)
    	SELECT 'CHECK_LOT_QTY_BY_LOT_MOVEMENT', 'Проверка итогов партий по движениям партий', 
               'Проверка равенства итогов партий (QUANTITY_ADD, QUANTITY_SUB, QUANTITY_RES)
сумме движений партий (проводок документов).', 
               1, 12, 'UTL_CHECK_LOT_QTY_BY_LOT_MOVEMENT'
        ---------------------
        INSERT @T (CODE, NAME, 
                   DESCRIPTION, 
                   IS_CORRECTABLE, SORT_ORDER, PROC_NAME)
    	SELECT 'LOT_QUANTITY_REM_LESS_ZERO', 'Проверка итогов партий (остаток, приход, расход, резерв)', 
               'Проверка итогов партий (остаток, приход, расход, резерв): 
Остаток партии меньше 0
или сумма итогов партии (приход - расход - резерв) не равно остатку партии.
Исправление не реализовано', 
               0, 13, 'UTL_LOT_QUANTITY_REM_LESS_ZERO'
        ---------------------
        INSERT @T (CODE, NAME, 
                   DESCRIPTION, 
                   IS_CORRECTABLE, SORT_ORDER, PROC_NAME)
    	SELECT 'LOT_MOVEMENT_WITH_SERO_QTY', 'Проводки с нулевыми количествами движения', 
               'Проводки, у которых все количества (приход, расход и резерв) равны 0.
Исправление не реализовано', 
               0, 14, 'UTL_LOT_MOVEMENT_WITH_SERO_QTY'
        ---------------------
        INSERT @T (CODE, NAME, 
                   DESCRIPTION, 
                   IS_CORRECTABLE, SORT_ORDER, PROC_NAME)
    	SELECT 'LOT_PRICE_SAL_LESS_PRICE_SUP', 'Сравнительная проверка цен партий', 
               'Проверка цен партий: 
Розничная цена меньше закупочной более чем на 10% или 
цена поставщика меньше цены производителя более чем на 10% или
цена поставщика меньше 0 или цена розничная меньше 0.
Исправление не реализовано', 
               0, 15, 'UTL_LOT_PRICE_SAL_LESS_PRICE_SUP'
        ---------------------
        INSERT @T (CODE, NAME, 
                   DESCRIPTION, 
                   IS_CORRECTABLE, SORT_ORDER, PROC_NAME)
    	SELECT 'BAD_PRICE_AFTER_DISASSEMBLING', 'Проверка на правильность цены партий после разукомплектации', 
               'Проверяются цены поставщика партии-потомка и партии-родителя с учетом коффициента деления.
Считается ошибкой, если разница между ними более 2 %.
Исправление не реализовано', 
               0, 16, 'UTL_BAD_PRICE_AFTER_DISASSEMBLING'
        ---------------------
        INSERT @T (CODE, NAME, 
                   DESCRIPTION, 
                   IS_CORRECTABLE, SORT_ORDER, PROC_NAME)
    	SELECT 'CHECK_LOT_DOCUMENT', 'Проверка партии и документа, ее породившую', 
               'Проверяется существование документа, породившего партию
и существование партии, порожденной документом.
Исправление не реализовано', 
               0, 17, 'UTL_CHECK_LOT_DOCUMENT'
        ---------------------
        INSERT @T (CODE, NAME, 
                   DESCRIPTION, 
                   IS_CORRECTABLE, SORT_ORDER, PROC_NAME)
    	SELECT 'CHECK_LOT_MOVEMENT_BY_DOC', 'Проверка на "потерянные" проводки', 
               'Поиск проводок, не принадлежащих никаким документам.
Реализовано для документов:
приходы, акт возврата поставщку, акт разукомплектации, 
кассовый чек, перемещение, акт возврата от покупателя, акт переоценки,
акт списания, расходные накладные, счета, сводные инвентаризации, производство', 
               1, 18, 'UTL_CHECK_LOT_MOVEMENT_BY_DOC'
        ---------------------
        INSERT @T (CODE, NAME, 
                   DESCRIPTION, 
                   IS_CORRECTABLE, SORT_ORDER, PROC_NAME)
    	SELECT 'CHECK_LOT_MOVEMENT_NOT_PROC_DOC', 'Проверка на непроведенные документы с проводками', 
               'Проверяется наличие непроведенных документов  (кроме кассовых смен и чеков),
имеющих хотя бы одну проводку.
При исправлении проводки удаляются.', 
               1, 19, 'UTL_CHECK_LOT_MOVEMENT_NOT_PROC_DOC'
        ---------------------

        INSERT @T (CODE, NAME, 
                   DESCRIPTION, 
                   IS_CORRECTABLE, SORT_ORDER, PROC_NAME)
    	SELECT 'CHECK_PROC_DOC_WOUT_LOT_MOVEMENT', 'Проверка на отсутствие проводок у проведенных документов', 
               'Проверяется наличие проведенных документов (кроме чеков),
(т.е. в состоянии "PROC" или "RES") не имеющих ни одной проводки.
Исправление реализовано для приходных накладных и актов разукомплектации.', 
               1, 20, 'UTL_CHECK_PROC_DOC_WOUT_LOT_MOVEMENT'
        ---------------------
        INSERT @T (CODE, NAME, 
                   DESCRIPTION, 
                   IS_CORRECTABLE, SORT_ORDER, PROC_NAME)
    	SELECT 'CHECK_PROC_CHEQUE_WOUT_LOT_MOVEMENT', 'Проверка на отсутствие проводок у проведенных чеков', 
               'Проверяется наличие проведенных чеков без проводок.
При исправлении проводки создаются заново по строкам чеков.', 
               1, 21, 'UTL_CHECK_PROC_CHEQUE_WOUT_LOT_MOVEMENT'
        ---------------------
        INSERT @T (CODE, NAME, 
                   DESCRIPTION, 
                   IS_CORRECTABLE, SORT_ORDER, PROC_NAME)
    	SELECT 'CHECK_LOT_MOVEMENT_WOUT_REF_ON_LOT', 'Проверка соответствия партии в проводках и в справочнике партий', 
               'Поиск в проводках партий, отсутствующих в справочнике партий.
Исправление не реализовано.', 
               0, 22, 'UTL_CHECK_LOT_MOVEMENT_WOUT_REF_ON_LOT'
        ---------------------
        INSERT @T (CODE, NAME, 
                   DESCRIPTION, 
                   IS_CORRECTABLE, SORT_ORDER, PROC_NAME)
    	SELECT 'CHECK_GOODS_MNEMOCODE', 'Проверка наличия мнемокода у товаров', 
               'Проверяется наличие мнемокода у товаров.
При исправлении мнемокоды присваиваются стандартной процедурой.', 
               1, 23, 'UTL_CHECK_GOODS_MNEMOCODE'
        ---------------------
        INSERT @T (CODE, NAME, 
                   DESCRIPTION, 
                   IS_CORRECTABLE, SORT_ORDER, PROC_NAME)
    	SELECT 'CORRECT_LOGIN_LANGUAGE', 'Проверка языка логинов сервера SQL', 
               'Поиск логинов, имеющих язык, отличный от English', 
               1, 24, 'UTL_CORRECT_LOGIN_LANGUAGE'
        ---------------------
        INSERT @T (CODE, NAME, 
                   DESCRIPTION, 
                   IS_CORRECTABLE, SORT_ORDER, PROC_NAME)
    	SELECT 'PRICE_LIST_ITEM_PRICE_DELETE_OLD', 'Удаление старых данных в истории цен прайс-листов (старее месяца)', 
               'Удаление старых данных в истории цен прайс-листов,
дата которых меньше текущей даты на 30 дней.
Как минимум одна строка в истории остается (с последней датой), даже если дата старая.',
               1, 25, 'UTL_PRICE_LIST_ITEM_PRICE_DELETE_OLD'
        ---------------------
        INSERT @T (CODE, NAME, 
                   DESCRIPTION, 
                   IS_CORRECTABLE, SORT_ORDER, PROC_NAME)
    	SELECT 'CHECK_CHEQUE_DOUBLE_LOT_MOVEMENT', 'Проверка задублированных проводок чеков', 
               'Поиск лишних проводок чеков - для одной строки чека есть более одной строки в проводках.',
               1, 26, 'UTL_CHECK_CHEQUE_DOUBLE_LOT_MOVEMENT'
        ---------------------
        INSERT @T (CODE, NAME, 
                   DESCRIPTION, 
                   IS_CORRECTABLE, SORT_ORDER, PROC_NAME)
    	SELECT 'CHECK_CHEQUE_SR_GOODS', 'Проверка товара и коэф.деления в строке чека и партии в строке чека', 
               'Товар в строке чека не совпадает с товаром партии в строке чека.
Исправление есть.
Код коэфициента деления в строке чека не совпадает с кодом коэффициента деления партии в строке чека
Исправление есть.',
               1, 27, 'UTL_CHECK_CHEQUE_SR_GOODS'
        ---------------------
	RETURN 
END
GO

/****** Object:  StoredProcedure [dbo].[UTL_CHECK_DATABASE]    Script Date: 09/01/2011 13:58:01 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER OFF
GO
IF OBJECT_ID(N'DBO.UTL_CHECK_DATABASE') IS NULL EXEC(N'CREATE PROCEDURE DBO.UTL_CHECK_DATABASE AS RETURN')
GO
--drop PROCEDURE [dbo].[UTL_CHECK_DATABASE]
ALTER PROCEDURE [dbo].[UTL_CHECK_DATABASE]
    @XML_DATA NTEXT
AS

DECLARE @HDOC INT,
        @STR NVARCHAR(500),
        @CODE VARCHAR(100),
        @IS_RUN BIT,
        @IS_CORRECT BIT,
        @IS_CORRECTABLE BIT,
        @PROC_NAME NVARCHAR(100)

IF OBJECT_ID('TEMPDB..#PROCEDURES') IS NOT NULL DROP TABLE #PROCEDURES

EXEC SP_XML_PREPAREDOCUMENT @HDOC OUTPUT , @XML_DATA OUTPUT
    SELECT * INTO #PROCEDURES FROM OPENXML(@HDOC , '/XML/ROW') WITH(
        CODE NVARCHAR(100) 'CODE',
        NAME NVARCHAR(256) 'NAME',
        DESCRIPTION NVARCHAR(1024) 'DESCRIPTION',
        IS_RUN BIT 'IS_RUN',
        IS_CORRECT BIT 'IS_CORRECT',
        IS_CORRECTABLE BIT 'IS_CORRECTABLE'
    )
EXEC SP_XML_REMOVEDOCUMENT @HDOC

IF EXISTS(SELECT TOP 1 1 FROM ES_EF2(NOLOCK)) BEGIN
    INSERT ES_GOODS_NORM(ID_GOODS_GLOBAL, [NAME])
    SELECT ID_GOODS_GLOBAL = GOODS.ID_GOODS_GLOBAL, [NAME] = DBO.FN_ES_NAME_NORM(GOODS.[NAME])
    FROM GOODS(NOLOCK) LEFT JOIN ES_GOODS_NORM (NOLOCK) ON GOODS.ID_GOODS_GLOBAL = ES_GOODS_NORM.ID_GOODS_GLOBAL
    WHERE ES_GOODS_NORM.ID_ES_GOODS_NORM IS NULL
END

-- запуск проверочных процедур
DECLARE CUR CURSOR LOCAL READ_ONLY
FOR 
SELECT  
    P.CODE, P.IS_RUN, P.IS_CORRECT, L.IS_CORRECTABLE, L.PROC_NAME
FROM #PROCEDURES P
    INNER JOIN DBO.FN_CHECK_DATABASE_LIST() L ON P.CODE = L.CODE
WHERE P.IS_RUN = 1 OR P.IS_CORRECT = 1
ORDER BY L.SORT_ORDER

OPEN CUR
    WHILE 1 = 1
    BEGIN
        FETCH NEXT FROM CUR INTO @CODE, @IS_RUN, @IS_CORRECT, @IS_CORRECTABLE, @PROC_NAME
        IF @@FETCH_STATUS <> 0 BREAK
        IF @IS_RUN = 1 BEGIN
            IF @IS_CORRECT = 0 BEGIN
                -- запуск только проверки
                SET @STR = @PROC_NAME + ' ''CHECK'''
                EXEC SP_EXECUTESQL @STR    
            END
            IF @IS_CORRECT = 1 AND @IS_CORRECTABLE = 1 BEGIN
                -- запуск проверки с исправлением
                SET @STR = @PROC_NAME + ' ''REPAIR'''
                EXEC SP_EXECUTESQL @STR    
            END
        END        
    END
CLOSE CUR
DEALLOCATE CUR

IF OBJECT_ID('TEMPDB..#PROCEDURES') IS NOT NULL DROP TABLE #PROCEDURES

RETURN
GO