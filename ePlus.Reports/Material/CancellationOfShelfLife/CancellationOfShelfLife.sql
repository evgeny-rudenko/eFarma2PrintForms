SET NOCOUNT ON
SET QUOTED_IDENTIFIER OFF
GO

IF OBJECT_ID('DBO.CANCELLATION_OF_SHELF_LIFE_RIGLA') IS NULL EXEC('CREATE PROCEDURE DBO.CANCELLATION_OF_SHELF_LIFE_RIGLA AS RETURN')
GO
ALTER  PROCEDURE DBO.CANCELLATION_OF_SHELF_LIFE_RIGLA
    @XMLPARAM NTEXT AS
    
    DECLARE @HDOC INT
	DECLARE @DATE_FR DATETIME
	DECLARE @DATE_TO DATETIME	
	DECLARE @MONTH VARCHAR(2)
	DECLARE @YEAR VARCHAR(4)
	DECLARE @ID_CONTRACTOR BIGINT
	DECLARE	@RESULT VARCHAR(4000)
	DECLARE	@SALES VARCHAR(4000)
	DECLARE	@DOC_NUMS VARCHAR(4000)
	DECLARE	@DOC_NUM VARCHAR(300)
		
EXEC SP_XML_PREPAREDOCUMENT @HDOC OUT, @XMLPARAM

SELECT
	@MONTH = [MONTH],
	@YEAR = [YEAR],
	@ID_CONTRACTOR = ID_CONTRACTOR
FROM OPENXML(@HDOC, '/XML') WITH(
	[MONTH] VARCHAR(2) 'MONTH',
	[YEAR] VARCHAR(4) 'YEAR',
	ID_CONTRACTOR BIGINT 'ID_CONTRACTOR'
)

EXEC SP_XML_REMOVEDOCUMENT @HDOC

SET @DATE_FR = DATEADD(D, 0, (@YEAR + '.' + @MONTH + '.' + '01'))
SET @DATE_TO = DATEADD(MONTH, 1, DATEADD(DAY, 1-day(@DATE_FR),@DATE_FR))-1

EXEC USP_RANGE_DAYS @DATE_FR OUT, @DATE_TO OUT
EXEC USP_RANGE_NORM @DATE_FR OUT, @DATE_TO OUT


CREATE TABLE #TEMP
(
	ID_GOODS BIGINT, 
	GOODSCODE VARCHAR(16), 
	GOODSNAME VARCHAR(255), 
	ID_CONTRACTOR BIGINT, 
	ID_STORE BIGINT,  
	STORE_NAME VARCHAR(100), 
	ID_LOT BIGINT, 
	ID_LOT_GLOBAL UNIQUEIDENTIFIER,  
	ID_LOT_BARCODE VARCHAR(40), 
	ID_SCALING_RATIO BIGINT, 
	ID_UNIT BIGINT, 
	UNIT_NAME VARCHAR(255), 
	QUANTITY_ADD MONEY, 
	REMAINS MONEY, 
	RESERVE MONEY, 
	ACCESSIBLE MONEY, 
	BEST_BEFORE DATETIME, 
	ID_SUPPLIER BIGINT, 
	SUPPLIER_NAME VARCHAR(100), 
	PRICE_SUP MONEY, 
	PRICE_SAL MONEY, 
	ON_THE_WAY BIT, 
	ID_CONTRACTS_GLOBAL UNIQUEIDENTIFIER, 
	INVOICE_DATE DATETIME, 
	CONTRACT VARCHAR(150), 
	DOC_NUM VARCHAR(300)
)

INSERT INTO #TEMP
        ( 
    ID_GOODS, 
	GOODSCODE, 
	GOODSNAME, 
	ID_CONTRACTOR, 
	ID_STORE, 
	STORE_NAME, 
	ID_LOT, 
	ID_LOT_GLOBAL,  
	ID_LOT_BARCODE, 
	ID_SCALING_RATIO, 
	ID_UNIT, 
	UNIT_NAME, 
	QUANTITY_ADD, 
	REMAINS, 
	RESERVE, 
	ACCESSIBLE, 
	BEST_BEFORE, 
	ID_SUPPLIER, 
	SUPPLIER_NAME, 
	PRICE_SUP, 
	PRICE_SAL, 
	ON_THE_WAY, 
	ID_CONTRACTS_GLOBAL, 
	INVOICE_DATE, 
	CONTRACT, 
	DOC_NUM
        )
SELECT    
    ID_GOODS, 
	GOODSCODE, 
	GOODSNAME, 
	ID_CONTRACTOR, 
	ID_STORE, 
	STORE_NAME, 
	ID_LOT, 
	ID_LOT_GLOBAL,  
	ID_LOT_BARCODE, 
	ID_SCALING_RATIO, 
	ID_UNIT, 
	UNIT_NAME, 
	QUANTITY_ADD, 
	REMAINS, 
	RESERVE, 
	ACCESSIBLE, 
	BEST_BEFORE, 
	ID_SUPPLIER, 
	SUPPLIER_NAME, 
	PRICE_SUP, 
	PRICE_SAL, 
	ON_THE_WAY, 
	ID_CONTRACTS_GLOBAL, 
	INVOICE_DATE, 
	CONTRACT, 
	DOC_NUM
        

--SELECT DISTINCT * 
--INTO #TEMP
FROM (
    SELECT 
		L.ID_GOODS, 
		GOODSCODE = G.CODE, 
		GOODSNAME = G.NAME,
        S.ID_CONTRACTOR,
		L.ID_STORE,
		STORE_NAME = S.NAME,
		L.ID_LOT,
		L.ID_LOT_GLOBAL,
		L.INTERNAL_BARCODE AS ID_LOT_BARCODE,
		L.ID_SCALING_RATIO,
		U.ID_UNIT,
		CAST(SR.NUMERATOR AS VARCHAR) + '/' + CAST(SR.DENOMINATOR AS VARCHAR) + ' ' + U.NAME AS UNIT_NAME,
        L.QUANTITY_ADD,
		L.QUANTITY_ADD - L.QUANTITY_SUB AS REMAINS,
		L.QUANTITY_RES AS RESERVE, 
		L.QUANTITY_REM AS ACCESSIBLE, 
		SER.BEST_BEFORE, 
		L.ID_SUPPLIER,
		SUPPLIER_NAME = SUP.NAME,
      	L.PRICE_SUP, 
      	L.PRICE_SAL,
        ON_THE_WAY = CONVERT(BIT, 0),
        L.ID_CONTRACTS_GLOBAL,
        L.INVOICE_DATE,
        L.INVOICE_NUM,
        CONTRACT = CNT.NAME, 
        DOC_NUM = I.INCOMING_NUMBER
	FROM DBO.LOT L WITH(NOLOCK)
	INNER JOIN GOODS G ON L.ID_GOODS = G.ID_GOODS
	INNER JOIN STORE S WITH(NOLOCK) ON S.ID_STORE = L.ID_STORE
	INNER JOIN SCALING_RATIO SR WITH(NOLOCK) ON SR.ID_SCALING_RATIO = L.ID_SCALING_RATIO
	LEFT JOIN CONTRACTOR SUP WITH(NOLOCK) ON SUP.ID_CONTRACTOR = L.ID_SUPPLIER
	LEFT OUTER JOIN DBO.UNIT U WITH(NOLOCK) ON SR.ID_UNIT = U.ID_UNIT
	LEFT OUTER JOIN DBO.SERIES SER WITH(NOLOCK) ON SER.ID_SERIES = L.ID_SERIES
    LEFT JOIN REG_CERT RC ON RC.ID_REG_CERT_GLOBAL = L.ID_REG_CERT_GLOBAL
    LEFT JOIN CONTRACTS CNT ON CNT.ID_CONTRACTS_GLOBAL = L.ID_CONTRACTS_GLOBAL
    --LEFT JOIN INVOICE_ITEM II ON II.ID_INVOICE_GLOBAL = L.ID_DOCUMENT
    LEFT JOIN INVOICE I ON I.ID_INVOICE_GLOBAL = L.ID_DOCUMENT --II.ID_INVOICE_GLOBAL
    LEFT JOIN (select 
                   ID_GOODS,
                   ID_CONTRACTOR,
                   AP_GROUP_AU
               from ASSORTMENT_PLAN AP 
               where DATE_DELETED IS NULL)AP on AP.ID_GOODS = L.ID_GOODS AND AP.ID_CONTRACTOR = S.ID_CONTRACTOR
    WHERE S.DATE_DELETED IS NULL
    AND NOT EXISTS (SELECT NULL
                    FROM INVOICE_ITEM II
                    INNER JOIN INVOICE I ON I.ID_INVOICE_GLOBAL = II.ID_INVOICE_GLOBAL
                    WHERE I.DOCUMENT_STATE='PROC'
                    AND I.ON_THE_WAY=1
                    AND II.ID_INVOICE_GLOBAL = L.ID_DOCUMENT
                    AND II.ID_INVOICE_ITEM_GLOBAL = L.ID_DOCUMENT_ITEM)
    AND SER.BEST_BEFORE BETWEEN @DATE_FR AND @DATE_TO
                    
    UNION ALL
    SELECT
		II.ID_GOODS,
		GOODSCODE = G.CODE, 
		GOODSNAME = G.NAME,
        S.ID_CONTRACTOR,
		I.ID_STORE,
		STORE_NAME = S.NAME,
		L.ID_LOT,
		L.ID_LOT_GLOBAL,
		L.INTERNAL_BARCODE AS ID_LOT_BARCODE,
		L.ID_SCALING_RATIO,
		U.ID_UNIT,
		CAST(SR.NUMERATOR AS VARCHAR) + '/' + CAST(SR.DENOMINATOR AS VARCHAR) + ' ' + U.NAME AS UNIT_NAME,
        II.QUANTITY,
		CONVERT(MONEY, NULL) AS REMAINS,
		CONVERT(MONEY, NULL) AS RESERVE, 
		CONVERT(MONEY, NULL) AS ACCESSIBLE, 
		SER.BEST_BEFORE, 
		L.ID_SUPPLIER,
		SUPPLIER_NAME = SUP.NAME,
      	L.PRICE_SUP, 
      	L.PRICE_SAL,
        ON_THE_WAY = CONVERT(BIT, 1),
        L.ID_CONTRACTS_GLOBAL,
        L.INVOICE_DATE,
        L.INVOICE_NUM,
        CNT.NAME, 
        I.INCOMING_NUMBER
    FROM INVOICE_ITEM II
    INNER JOIN GOODS G ON II.ID_GOODS = G.ID_GOODS
    INNER JOIN INVOICE I ON I.ID_INVOICE_GLOBAL = II.ID_INVOICE_GLOBAL
    INNER JOIN STORE S ON S.ID_STORE = I.ID_STORE
    INNER JOIN LOT L ON L.ID_DOCUMENT = I.ID_INVOICE_GLOBAL AND L.ID_DOCUMENT_ITEM = II.ID_INVOICE_ITEM_GLOBAL
    INNER JOIN SCALING_RATIO SR ON SR.ID_SCALING_RATIO = II.ID_SCALING_RATIO    
    INNER JOIN UNIT U ON U.ID_UNIT = SR.ID_UNIT
    INNER JOIN CONTRACTOR SUP ON SUP.ID_CONTRACTOR = I.ID_CONTRACTOR_SUPPLIER
    LEFT JOIN SERIES SER ON SER.ID_SERIES = II.ID_SERIES
    LEFT JOIN REG_CERT RC ON RC.ID_REG_CERT_GLOBAL = II.ID_REG_CERT_GLOBAL
    LEFT JOIN CONTRACTS CNT ON CNT.ID_CONTRACTS_GLOBAL = L.ID_CONTRACTS_GLOBAL
    LEFT JOIN (select
                   ID_GOODS,
                   ID_CONTRACTOR,
                   AP_GROUP_AU
               from ASSORTMENT_PLAN AP 
               where DATE_DELETED IS NULL)AP on AP.ID_GOODS = II.ID_GOODS AND AP.ID_CONTRACTOR = S.ID_CONTRACTOR

    WHERE I.DOCUMENT_STATE='PROC'
    AND I.ON_THE_WAY=1
    AND S.DATE_DELETED IS NULL
    AND SER.BEST_BEFORE BETWEEN @DATE_FR AND @DATE_TO    
    ) TAB
    WHERE TAB.BEST_BEFORE IS NOT NULL 
    AND TAB.ID_CONTRACTOR = @ID_CONTRACTOR
    AND TAB.REMAINS > 0
    
/*Создаем таблицу с парами айдишников лотов, датами и ценами*/
SELECT 
	L.ID_LOT AS PARENT_ID, L_NEW.ID_LOT AS CHILD_ID, AR.DATE AS PRICE_DATE, L_NEW.PRICE_SAL AS PRICE_SAL
INTO #LOTS
FROM ACT_REVALUATION2 AR
			INNER JOIN ACT_REVALUATION2_ITEM ARI ON ARI.ID_ACT_REVALUATION2_GLOBAL = AR.ID_ACT_REVALUATION2_GLOBAL
			INNER JOIN LOT L ON ARI.ID_LOT_GLOBAL = L.ID_LOT_GLOBAL
			INNER JOIN LOT L_NEW ON L_NEW.ID_DOCUMENT = ARI.ID_ACT_REVALUATION2_GLOBAL 
                        AND L_NEW.ID_DOCUMENT_ITEM = ARI.ID_ACT_REVALUATION2_ITEM_GLOBAL
			WHERE AR.DOCUMENT_STATE = 'PROC'
ORDER BY L.ID_LOT, L_NEW.ID_LOT

CREATE INDEX I_LP ON #LOTS(PARENT_ID)
CREATE INDEX I_LC ON #LOTS(CHILD_ID)

--SELECT * FROM #LOTS

CREATE TABLE #LOT_PAIRS(PARENT_ID BIGINT, CHILD_ID BIGINT, PRICE_DATE DATETIME, PRICE_SAL MONEY)
DECLARE @PARENT_ID BIGINT

DECLARE @ROWS INT
CREATE TABLE #PROM(ID BIGINT)
CREATE TABLE #PROM_T(ID BIGINT)
DECLARE PC CURSOR FOR SELECT DISTINCT L.PARENT_ID FROM #LOTS L
OPEN PC
WHILE (1=1)
BEGIN
	FETCH FROM PC INTO @PARENT_ID
	IF @@fetch_status=-1 
      BREAK
	IF @@fetch_status=-2
      CONTINUE
    INSERT INTO #PROM
            ( ID )
	SELECT L.CHILD_ID
	FROM #LOTS L
	WHERE L.PARENT_ID = @PARENT_ID

	INSERT INTO #LOT_PAIRS(PARENT_ID, CHILD_ID, PRICE_DATE, PRICE_SAL)
	SELECT @PARENT_ID, P.ID, L.PRICE_DATE, L.PRICE_SAL 
	FROM #PROM P
	INNER JOIN #LOTS L ON L.CHILD_ID = P.ID
		 
    WHILE (1=1)
    BEGIN
		INSERT INTO #LOT_PAIRS(PARENT_ID, CHILD_ID, PRICE_DATE, PRICE_SAL)
    	SELECT 
    		@PARENT_ID, 
			L.CHILD_ID, 
			L.PRICE_DATE, 
			L.PRICE_SAL
		FROM #LOTS L
		INNER JOIN #PROM P ON P.ID = L.PARENT_ID
		
		INSERT INTO #LOT_PAIRS(PARENT_ID, CHILD_ID, PRICE_DATE, PRICE_SAL)
		SELECT L.CHILD_ID, NULL, L.PRICE_DATE, L.PRICE_SAL 
		FROM #LOTS L
		WHERE L.CHILD_ID IN (SELECT ID FROM #PROM P WHERE L.CHILD_ID = P.ID)
			AND NOT EXISTS
			(SELECT NULL FROM #LOTS L1 WHERE L.CHILD_ID = L1.PARENT_ID)
		
		INSERT INTO #PROM_T(ID)
		SELECT 
			L.CHILD_ID
		FROM #LOTS L
		INNER JOIN #PROM P ON P.ID = L.PARENT_ID
		
		SET @ROWS = @@ROWCOUNT
		
		DELETE FROM #PROM
		INSERT INTO #PROM (ID)
		SELECT ID FROM #PROM_T
		
		DELETE FROM #PROM_T
		IF @ROWS = 0 BREAK
    END
END	
DEALLOCATE PC
CREATE INDEX I_CH ON #LOT_PAIRS(CHILD_ID)
CREATE INDEX I_PR ON #LOT_PAIRS(PARENT_ID)

DROP TABLE #PROM_T
DROP TABLE #PROM
DROP TABLE #LOTS
/*конец*/    

/*таблица с историей номеров документов поставщиков*/  
-- записываем во врем табл айдишники партии, родительской, партии если она есть, и номер накладной 
SELECT ID, PARENT_ID, DOC_NUM
INTO #DOC_NUMS
FROM
(
SELECT DISTINCT
	L.ID_LOT AS ID, 
	L_P.ID_LOT AS PARENT_ID, 
	I.INCOMING_NUMBER AS DOC_NUM
FROM /*LOT T --*/ACT_REVALUATION2 AR
			/*--*/INNER JOIN ACT_REVALUATION2_ITEM ARI ON ARI.ID_ACT_REVALUATION2_GLOBAL = AR.ID_ACT_REVALUATION2_GLOBAL
			LEFT JOIN LOT L ON /*T.ID_LOT = L.ID_LOT --*/ARI.ID_LOT_GLOBAL = L.ID_LOT_GLOBAL
			LEFT JOIN LOT L_P ON L.ID_PARENT = L_P.ID_LOT_GLOBAL
			LEFT JOIN INVOICE_ITEM II ON II.ID_INVOICE_GLOBAL = L.ID_DOCUMENT
			LEFT JOIN INVOICE I ON I.ID_INVOICE_GLOBAL = II.ID_INVOICE_GLOBAL
UNION
SELECT DISTINCT
	T.ID_LOT AS ID, 
	L_P1.ID_LOT AS PARENT_ID, 
	I1.INCOMING_NUMBER AS DOC_HUM
FROM #TEMP T
	INNER JOIN LOT L1 ON L1.ID_LOT = T.ID_LOT
	LEFT JOIN LOT L_P1 ON L1.ID_PARENT = L_P1.ID_LOT_GLOBAL
	LEFT JOIN INVOICE_ITEM II1 ON II1.ID_INVOICE_GLOBAL = L1.ID_DOCUMENT
	LEFT JOIN INVOICE I1 ON I1.ID_INVOICE_GLOBAL = II1.ID_INVOICE_GLOBAL
) L
ORDER BY L.ID, L.PARENT_ID

CREATE INDEX I_DP ON #DOC_NUMS(PARENT_ID)
CREATE INDEX I_DC ON #DOC_NUMS(ID)

-- таблица для айдишников партий и номеров накладных
-- содержит 1 вариант айди и номера для всего дерева партий с одним родителем
CREATE TABLE #DOC_NUM_PAIRS(ID BIGINT, DOC_NUM VARCHAR(50))
DECLARE @ID BIGINT
SET @ROWS = NULL
CREATE TABLE #PROMD(ID BIGINT)
CREATE TABLE #PROM_TD(ID BIGINT)
DECLARE PC1 CURSOR FOR SELECT DISTINCT D.ID FROM #DOC_NUMS D
	INNER JOIN #TEMP T ON D.ID = T.ID_LOT
OPEN PC1
WHILE (1=1)
BEGIN
	FETCH FROM PC1 INTO @ID
	IF @@fetch_status=-1 
      BREAK
	IF @@fetch_status=-2
      CONTINUE
      
	INSERT INTO #DOC_NUM_PAIRS(ID, DOC_NUM)
	SELECT @ID, L.DOC_NUM
	FROM #DOC_NUMS L
	WHERE L.ID = @ID
	AND NOT EXISTS(
			SELECT * FROM #DOC_NUM_PAIRS A
			WHERE A.ID = @ID AND (A.DOC_NUM = L.DOC_NUM
			OR (A.DOC_NUM IS NULL AND L.DOC_NUM IS NULL)))
	AND L.DOC_NUM IS NOT NULL AND L.DOC_NUM <> ''
	
	-- заносим во врем табл родительские айдишники партий с очередным айди
    INSERT INTO #PROMD
            ( ID )
	SELECT L.PARENT_ID
	FROM #DOC_NUMS L
	WHERE L.ID = @ID
		 
    WHILE (1=1)
    BEGIN
		-- если такой айдишник партии в табл уже содержит номер партии, идем дальше
		-- иначе вставляем его
		-- суть в сохранении во врем табл 1 номера накладной для очередного айди партии
		SET @DOC_NUM = ''
		SELECT TOP 1 @DOC_NUM = D.DOC_NUM
		FROM #DOC_NUM_PAIRS D
		WHERE D.ID = @ID
		IF @DOC_NUM <> '' AND @DOC_NUM IS NOT NULL BREAK
		
		INSERT INTO #DOC_NUM_PAIRS(ID, DOC_NUM)
    	SELECT 
    		@ID,  
			L.DOC_NUM
		FROM #DOC_NUMS L
		INNER JOIN #PROMD P ON P.ID = L.ID
		/**/WHERE NOT EXISTS(
			SELECT * FROM #DOC_NUM_PAIRS A
			WHERE A.ID = @ID AND (A.DOC_NUM = L.DOC_NUM
			OR (A.DOC_NUM IS NULL AND L.DOC_NUM IS NULL)))
		AND L.DOC_NUM IS NOT NULL AND L.DOC_NUM <> ''
		
		INSERT INTO #DOC_NUM_PAIRS(ID, DOC_NUM)
		SELECT L.ID, DOC_NUM
		FROM #DOC_NUMS L
		WHERE L.PARENT_ID IN (SELECT ID FROM #PROMD P WHERE L.PARENT_ID = P.ID)
			AND NOT EXISTS
			(SELECT NULL FROM #DOC_NUMS L1 WHERE L.PARENT_ID = L1.ID)
			AND NOT EXISTS(
			SELECT * FROM #DOC_NUM_PAIRS A
			WHERE A.ID = @ID AND (A.DOC_NUM = L.DOC_NUM
			OR (A.DOC_NUM IS NULL AND L.DOC_NUM IS NULL)))
		AND L.DOC_NUM IS NOT NULL AND L.DOC_NUM <> ''	
		
		INSERT INTO #PROM_TD(ID)
		SELECT 
			L.PARENT_ID
		FROM #DOC_NUMS L
		INNER JOIN #PROMD P ON P.ID = L.ID
		
		SET @ROWS = @@ROWCOUNT
		
		DELETE FROM #PROMD
		
		INSERT INTO #PROMD (ID)
		SELECT ID FROM #PROM_TD
		
		DELETE FROM #PROM_TD
		IF @ROWS = 0 BREAK
    END
END	
DEALLOCATE PC1
CREATE INDEX I_ID_D ON #DOC_NUM_PAIRS(ID)

DROP TABLE #PROM_TD
DROP TABLE #PROMD
DROP TABLE #DOC_NUMS

/*конец*/

		CREATE TABLE #REV_DATES
		(
			ID_LOT BIGINT,	
			DATES VARCHAR(4000), 
			SALES VARCHAR(4000), 
			DOC_NUMS VARCHAR(4000)
		)

		DECLARE [GS$CURSOR] CURSOR LOCAL FAST_FORWARD
		FOR SELECT DISTINCT
			[GS].ID_LOT, 
			[GS].ID_GOODS, 
			[GS].BEST_BEFORE
		FROM #TEMP GS
		ORDER BY GS.ID_LOT
		
		CREATE TABLE #LPRICE
		(
			ID_GOODS BIGINT, 
			ID_LOT BIGINT, 
			DATE_OP DATETIME, 
			PRICE_SAL MONEY, 
			BEST_BEFORE DATETIME
		)
		
		INSERT INTO #LPRICE
		        ( ID_GOODS ,
		          ID_LOT ,
		          DATE_OP ,
		          PRICE_SAL ,
		          BEST_BEFORE
		        )	
		SELECT 
				L.ID_GOODS, 
				L.ID_LOT, 
				LM.DATE_OP, 
				L.PRICE_SAL, 
				S.BEST_BEFORE
			FROM LOT_MOVEMENT LM
			INNER JOIN LOT L ON LM.ID_LOT_GLOBAL = L.ID_LOT_GLOBAL
			INNER JOIN GOODS G ON L.ID_GOODS = G.ID_GOODS
			INNER JOIN SERIES S ON L.ID_SERIES = S.ID_SERIES
			WHERE 
				LM.CODE_OP IN ('INVOICE_OUT','CHEQUE')
				AND LM.QUANTITY_SUB>0
				AND S.BEST_BEFORE IS NOT NULL
		
		CREATE INDEX IDGOODS ON #LPRICE(ID_GOODS)
		CREATE INDEX IDLOTS ON #LPRICE(ID_LOT)
		CREATE INDEX BB ON #LPRICE(BEST_BEFORE)
		
		DECLARE		@ID_LOT BIGINT
		DECLARE		@ID_GOODS BIGINT
		DECLARE		@BEST_BEFORE DATETIME
		
		OPEN [GS$CURSOR]
		WHILE 1 = 1 
		BEGIN
			FETCH NEXT FROM [GS$CURSOR] INTO
				@ID_LOT, @ID_GOODS, @BEST_BEFORE
			IF @@FETCH_STATUS <> 0 BREAK
			
			SET @RESULT = ''
			SET @SALES = ''
			SET @DOC_NUMS = ''
			SET @DOC_NUM = ''
			
			SELECT 
				@RESULT = 
				CASE WHEN (@RESULT IS NULL OR @RESULT = '') THEN  
					CONVERT(CHAR(10),LP.PRICE_DATE,104) + ' ' + CONVERT(CHAR(5),LP.PRICE_DATE,108) + ' (' + CAST(LP.PRICE_SAL AS VARCHAR(20)) + ')'
				ELSE 
					@RESULT + '; ' + CONVERT(CHAR(10),LP.PRICE_DATE,104) + ' ' + CONVERT(CHAR(5),LP.PRICE_DATE,108) + ' (' + CAST(LP.PRICE_SAL AS VARCHAR(20)) + ')'
				END
			FROM (SELECT DISTINCT * FROM #LOT_PAIRS) LP
			WHERE LP.PARENT_ID = @ID_LOT
			ORDER BY LP.PRICE_DATE
			
			SELECT TOP 1 @DOC_NUM = DNP.DOC_NUM
			FROM #DOC_NUM_PAIRS DNP
			WHERE DNP.ID = @ID_LOT
			AND DNP.DOC_NUM IS NOT NULL AND DNP.DOC_NUM <> ''
			ORDER BY DNP.DOC_NUM
			
			/*SELECT 
				@DOC_NUMS = 
				CASE WHEN (@DOC_NUMS IS NULL OR @DOC_NUMS = '') THEN  
					DNP.DOC_NUM
				ELSE 
					@DOC_NUMS + '; ' + DNP.DOC_NUM
				END
			FROM (SELECT * FROM #DOC_NUM_PAIRS) DNP
			WHERE DNP.ID = @ID_LOT
			AND DNP.DOC_NUM IS NOT NULL AND DNP.DOC_NUM <> ''
			ORDER BY DNP.DOC_NUM*/
			
			SELECT 
				@SALES = 
				CASE WHEN (@SALES IS NULL OR @SALES = '') THEN  
					CONVERT(CHAR(10),LM.DATE_OP,104) + ' ' + CONVERT(CHAR(5),LM.DATE_OP,108) + ' (' + CAST(LM.PRICE_SAL AS VARCHAR(20)) + ')'
				ELSE 
					@SALES + '; ' + CONVERT(CHAR(10),LM.DATE_OP,104) + ' ' + CONVERT(CHAR(5),LM.DATE_OP,108) + ' (' + CAST(LM.PRICE_SAL AS VARCHAR(20)) + ')'
				END
			FROM #LPRICE LM
			WHERE 
				LM.ID_GOODS = @ID_GOODS
				AND LM.ID_LOT <> @ID_LOT
				AND LM.BEST_BEFORE>@BEST_BEFORE
			ORDER BY LM.DATE_OP
				
			INSERT INTO #REV_DATES
			(
				ID_LOT,
				DATES, 
				SALES, 
				DOC_NUMS
			)
			VALUES
			(
				@ID_LOT,
				@RESULT, 
				@SALES, 
				@DOC_NUM
			)
			
			END
		CLOSE [GS$CURSOR]
		DEALLOCATE [GS$CURSOR]
		DROP TABLE #LPRICE
DROP TABLE #LOT_PAIRS		
DROP TABLE #DOC_NUM_PAIRS

SELECT 
	ID_GOODS = T.ID_GOODS,  
	GOODSCODE = T.GOODSCODE, 
	GOODSNAME = T.GOODSNAME, 
	UNIT_NAME = T.UNIT_NAME, 
	SUPPLIER_NAME = T.SUPPLIER_NAME, 
	INVOICE_DATE = T.INVOICE_DATE, 
	REMAINS = T.REMAINS, 
	PRICE_SUP = T.PRICE_SUP,
	SUM_SUP = T.REMAINS * T.PRICE_SUP, 
	PRICE_SAL = T.PRICE_SAL, 
	BEST_BEFORE = T.BEST_BEFORE, 
	REV_DATES = RD.DATES,
	SALES = RD.SALES, 
	DOC_NUM = RD.DOC_NUMS
FROM #TEMP T
LEFT JOIN #REV_DATES RD ON T.ID_LOT = RD.ID_LOT
--WHERE T.REMAINS > 0 
--AND T.BEST_BEFORE BETWEEN @DATE_FR AND @DATE_TO 
GO

--exec CANCELLATION_OF_SHELF_LIFE_RIGLA @xmlParam=N'<XML><MONTH>11</MONTH><YEAR>2010</YEAR><ID_CONTRACTOR>5271</ID_CONTRACTOR></XML>'